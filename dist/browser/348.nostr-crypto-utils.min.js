/*! For license information please see 348.nostr-crypto-utils.min.js.LICENSE.txt */
"use strict";(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[348],{967(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.isNegativeLE=void 0,t.mod=h,t.pow=function(e,t,n){return B(R(n),e,t)},t.pow2=function(e,t,n){let r=e;for(;t-- >o;)r*=r,r%=n;return r},t.invert=w,t.tonelliShanks=b,t.FpSqrt=y,t.validateField=function(e){const t=q.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,r._validateObject)(e,t),e},t.FpPow=B,t.FpInvertBatch=v,t.FpDiv=function(e,t,n){return e.mul(t,"bigint"==typeof n?w(n,e.ORDER):e.inv(n))},t.FpLegendre=O,t.FpIsSquare=function(e,t){return 1===O(e,t)},t.nLength=N,t.Field=R,t.FpSqrtOdd=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const n=e.sqrt(t);return e.isOdd(n)?n:e.neg(n)},t.FpSqrtEven=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const n=e.sqrt(t);return e.isOdd(n)?e.neg(n):n},t.hashToPrivateScalar=function(e,t,n=!1){const o=(e=(0,r.ensureBytes)("privateHash",e)).length,s=N(t).nByteLength+8;if(s<24||o<s||o>1024)throw new Error("hashToPrivateScalar: expected "+s+"-1024 bytes of input, got "+o);return h(n?(0,r.bytesToNumberLE)(e):(0,r.bytesToNumberBE)(e),t-i)+i},t.getFieldBytesLength=L,t.getMinHashLength=T,t.mapHashToField=function(e,t,n=!1){const o=e.length,s=L(t),u=T(t);if(o<16||o<u||o>1024)throw new Error("expected "+u+"-1024 bytes of input, got "+o);const l=h(n?(0,r.bytesToNumberLE)(e):(0,r.bytesToNumberBE)(e),t-i)+i;return n?(0,r.numberToBytesLE)(l,s):(0,r.numberToBytesBE)(l,s)};const r=n(627),o=BigInt(0),i=BigInt(1),s=BigInt(2),u=BigInt(3),l=BigInt(4),f=BigInt(5),d=BigInt(7),c=BigInt(8),a=BigInt(9),g=BigInt(16);function h(e,t){const n=e%t;return n>=o?n:t+n}function w(e,t){if(e===o)throw new Error("invert: expected non-zero number");if(t<=o)throw new Error("invert: expected positive modulus, got "+t);let n=h(e,t),r=t,s=o,u=i,l=i,f=o;for(;n!==o;){const e=r/n,t=r%n,o=s-l*e,i=u-f*e;r=n,n=t,s=l,u=f,l=o,f=i}if(r!==i)throw new Error("invert: does not exist");return h(s,t)}function E(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function m(e,t){const n=(e.ORDER+i)/l,r=e.pow(t,n);return E(e,r,t),r}function p(e,t){const n=(e.ORDER-f)/c,r=e.mul(t,s),o=e.pow(r,n),i=e.mul(t,o),u=e.mul(e.mul(i,s),o),l=e.mul(i,e.sub(u,e.ONE));return E(e,l,t),l}function b(e){if(e<u)throw new Error("sqrt is not defined for small field");let t=e-i,n=0;for(;t%s===o;)t/=s,n++;let r=s;const l=R(e);for(;1===O(l,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return m;let f=l.pow(r,t);const d=(t+i)/s;return function(e,r){if(e.is0(r))return r;if(1!==O(e,r))throw new Error("Cannot find square root");let o=n,s=e.mul(e.ONE,f),u=e.pow(r,t),l=e.pow(r,d);for(;!e.eql(u,e.ONE);){if(e.is0(u))return e.ZERO;let t=1,n=e.sqr(u);for(;!e.eql(n,e.ONE);)if(t++,n=e.sqr(n),t===o)throw new Error("Cannot find square root");const r=i<<BigInt(o-t-1),f=e.pow(s,r);o=t,s=e.sqr(f),u=e.mul(u,s),l=e.mul(l,f)}return l}}function y(e){return e%l===u?m:e%c===f?p:e%g===a?function(e){const t=R(e),n=b(e),r=n(t,t.neg(t.ONE)),o=n(t,r),i=n(t,t.neg(r)),s=(e+d)/g;return(e,t)=>{let n=e.pow(t,s),u=e.mul(n,r);const l=e.mul(n,o),f=e.mul(n,i),d=e.eql(e.sqr(u),t),c=e.eql(e.sqr(l),t);n=e.cmov(n,u,d),u=e.cmov(f,l,c);const a=e.eql(e.sqr(u),t),g=e.cmov(n,u,a);return E(e,g,t),g}}(e):b(e)}t.isNegativeLE=(e,t)=>(h(e,t)&i)===i;const q=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function B(e,t,n){if(n<o)throw new Error("invalid exponent, negatives unsupported");if(n===o)return e.ONE;if(n===i)return t;let r=e.ONE,s=t;for(;n>o;)n&i&&(r=e.mul(r,s)),s=e.sqr(s),n>>=i;return r}function v(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),o=t.reduce((t,n,o)=>e.is0(n)?t:(r[o]=t,e.mul(t,n)),e.ONE),i=e.inv(o);return t.reduceRight((t,n,o)=>e.is0(n)?t:(r[o]=e.mul(t,r[o]),e.mul(t,n)),i),r}function O(e,t){const n=(e.ORDER-i)/s,r=e.pow(t,n),o=e.eql(r,e.ONE),u=e.eql(r,e.ZERO),l=e.eql(r,e.neg(e.ONE));if(!o&&!u&&!l)throw new Error("invalid Legendre symbol result");return o?1:u?0:-1}function N(e,t){void 0!==t&&(0,r.anumber)(t);const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function R(e,t,n=!1,s={}){if(e<=o)throw new Error("invalid field: expected ORDER > 0, got "+e);let u,l,f,d=!1;if("object"==typeof t&&null!=t){if(s.sqrt||n)throw new Error("cannot specify opts in two arguments");const e=t;e.BITS&&(u=e.BITS),e.sqrt&&(l=e.sqrt),"boolean"==typeof e.isLE&&(n=e.isLE),"boolean"==typeof e.modFromBytes&&(d=e.modFromBytes),f=e.allowedLengths}else"number"==typeof t&&(u=t),s.sqrt&&(l=s.sqrt);const{nBitLength:c,nByteLength:a}=N(e,u);if(a>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let g;const E=Object.freeze({ORDER:e,isLE:n,BITS:c,BYTES:a,MASK:(0,r.bitMask)(c),ZERO:o,ONE:i,allowedLengths:f,create:t=>h(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return o<=t&&t<e},is0:e=>e===o,isValidNot0:e=>!E.is0(e)&&E.isValid(e),isOdd:e=>(e&i)===i,neg:t=>h(-t,e),eql:(e,t)=>e===t,sqr:t=>h(t*t,e),add:(t,n)=>h(t+n,e),sub:(t,n)=>h(t-n,e),mul:(t,n)=>h(t*n,e),pow:(e,t)=>B(E,e,t),div:(t,n)=>h(t*w(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>w(t,e),sqrt:l||(t=>(g||(g=y(e)),g(E,t))),toBytes:e=>n?(0,r.numberToBytesLE)(e,a):(0,r.numberToBytesBE)(e,a),fromBytes:(t,o=!0)=>{if(f){if(!f.includes(t.length)||t.length>a)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+t.length);const e=new Uint8Array(a);e.set(t,n?0:e.length-t.length),t=e}if(t.length!==a)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+t.length);let i=n?(0,r.bytesToNumberLE)(t):(0,r.bytesToNumberBE)(t);if(d&&(i=h(i,e)),!o&&!E.isValid(i))throw new Error("invalid field element: outside of range 0..ORDER");return i},invertBatch:e=>v(E,e),cmov:(e,t,n)=>n?t:e});return Object.freeze(E)}function L(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function T(e){const t=L(e);return t+Math.ceil(t/2)}}}]);