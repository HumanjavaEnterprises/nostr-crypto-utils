(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[446],{8300(t,i,e){"use strict";var n=e(8510),r=e(3039),a=e(1565);new class{constructor(){this.cryptoInstance=null,this.initPromise=this.initialize()}async initialize(){this.cryptoInstance=await(async()=>{if("undefined"!=typeof window)return{};if(void 0!==e.g)return{};try{const t=await Promise.resolve().then(e.t.bind(e,1565,19));if(t.webcrypto)return t.webcrypto}catch{r.vF.debug("Node crypto not available, falling back to crypto-browserify")}return a})()}async ensureInitialized(){if(await this.initPromise,!this.cryptoInstance)throw new Error("Crypto implementation not initialized");return this.cryptoInstance}async getSubtle(){return(await this.ensureInitialized()).subtle}async getRandomValues(t){return(await this.ensureInitialized()).getRandomValues(t)}},n.ko.sign,n.ko.verify},7600(t,i,e){"use strict";e(8090),e(8300),e(965);var n=e(3039),r=e(1565);new class{constructor(){this.cryptoInstance=null,this.initPromise=this.initialize()}async initialize(){this.cryptoInstance=await(async()=>{if("undefined"!=typeof window)return{};if(void 0!==e.g)return{};try{const t=await Promise.resolve().then(e.t.bind(e,1565,19));if(t.webcrypto)return t.webcrypto}catch{n.vF.debug("Node crypto not available, falling back to crypto-browserify")}return r})()}async ensureInitialized(){if(await this.initPromise,!this.cryptoInstance)throw new Error("Crypto implementation not initialized");return this.cryptoInstance}async getSubtle(){return(await this.ensureInitialized()).subtle}async getRandomValues(t){return(await this.ensureInitialized()).getRandomValues(t)}},e(2343),e(8287),e(8287).Buffer},8982(){},7790(){},1638(){},2668(){},7965(){},6089(){},9368(){},4688(){},1069(){},3779(){},7199(){}}]);