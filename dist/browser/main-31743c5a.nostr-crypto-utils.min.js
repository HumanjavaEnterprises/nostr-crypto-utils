"use strict";(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[428],{300(t,i,e){var n=e(510),r=e(39);new class{constructor(){this.cryptoInstance=null,this.initPromise=this.initialize()}async initialize(){this.cryptoInstance=await(async()=>{if("undefined"!=typeof window)return{};if(void 0!==e.g)return{};try{const t=await Promise.resolve().then(e.bind(e,300));if(t.webcrypto)return t.webcrypto}catch{r.vF.debug("Node crypto not available")}throw new Error("No WebCrypto implementation available")})()}async ensureInitialized(){if(await this.initPromise,!this.cryptoInstance)throw new Error("Crypto implementation not initialized");return this.cryptoInstance}async getSubtle(){return(await this.ensureInitialized()).subtle}async getRandomValues(t){return(await this.ensureInitialized()).getRandomValues(t)}},n.ko.sign,n.ko.verify},600(t,i,e){e(90),e(300),e(965);var n=e(39);new class{constructor(){this.cryptoInstance=null,this.initPromise=this.initialize()}async initialize(){this.cryptoInstance=await(async()=>{if("undefined"!=typeof window)return{};if(void 0!==e.g)return{};try{const t=await Promise.resolve().then(e.bind(e,300));if(t.webcrypto)return t.webcrypto}catch{n.vF.debug("Node crypto not available")}throw new Error("No WebCrypto implementation available")})()}async ensureInitialized(){if(await this.initPromise,!this.cryptoInstance)throw new Error("Crypto implementation not initialized");return this.cryptoInstance}async getSubtle(){return(await this.ensureInitialized()).subtle}async getRandomValues(t){return(await this.ensureInitialized()).getRandomValues(t)}},e(343),e(287)}}]);