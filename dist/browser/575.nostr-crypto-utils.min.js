/*! For license information please see 575.nostr-crypto-utils.min.js.LICENSE.txt */
"use strict";(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[575],{562(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.getHash=function(e){return{hash:e}},t.createCurve=function(e,t){const r=t=>(0,n.weierstrass)({...e,hash:t});return{...r(t),create:r}};const n=r(705)},422(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.wNAF=void 0,t.negateCt=a,t.normalizeZ=function(e,t){const r=(0,o.FpInvertBatch)(e.Fp,t.map(e=>e.Z));return t.map((t,n)=>e.fromAffine(t.toAffine(r[n])))},t.mulEndoUnsafe=function(e,t,r,n){let o=t,a=e.ZERO,c=e.ZERO;for(;r>i||n>i;)r&s&&(a=a.add(o)),n&s&&(c=c.add(o)),o=o.double(),r>>=s,n>>=s;return{p1:a,p2:c}},t.pippenger=function(e,t,r,o){d(r,e),l(o,t);const i=r.length,s=o.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const a=e.ZERO,c=(0,n.bitLen)(BigInt(i));let f=1;c>12?f=c-3:c>4?f=c-2:c>0&&(f=2);const u=(0,n.bitMask)(f),h=new Array(Number(u)+1).fill(a);let p=a;for(let e=Math.floor((t.BITS-1)/f)*f;e>=0;e-=f){h.fill(a);for(let t=0;t<s;t++){const n=o[t],i=Number(n>>BigInt(e)&u);h[i]=h[i].add(r[t])}let t=a;for(let e=h.length-1,r=a;e>0;e--)r=r.add(h[e]),t=t.add(r);if(p=p.add(t),0!==e)for(let e=0;e<f;e++)p=p.double()}return p},t.precomputeMSMUnsafe=function(e,t,r,o){c(o,t.BITS),d(r,e);const i=e.ZERO,s=2**o-1,a=Math.ceil(t.BITS/o),f=(0,n.bitMask)(o),u=r.map(e=>{const t=[];for(let r=0,n=e;r<s;r++)t.push(n),n=n.add(e);return t});return e=>{if(l(e,t),e.length>r.length)throw new Error("array of scalars must be smaller than array of points");let n=i;for(let t=0;t<a;t++){if(n!==i)for(let e=0;e<o;e++)n=n.double();const r=BigInt(a*o-(t+1)*o);for(let t=0;t<e.length;t++){const o=e[t],i=Number(o>>r&f);i&&(n=n.add(u[t][i-1]))}}return n}},t.validateBasic=function(e){return(0,o.validateField)(e.Fp),(0,n.validateObject)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,o.nLength)(e.n,e.nBitLength),...e,p:e.Fp.ORDER})},t._createCurveFields=function(e,t,r={},n){if(void 0===n&&(n="edwards"===e),!t||"object"!=typeof t)throw new Error(`expected valid ${e} CURVE object`);for(const e of["p","n","h"]){const r=t[e];if(!("bigint"==typeof r&&r>i))throw new Error(`CURVE.${e} must be positive bigint`)}const o=b(t.p,r.Fp,n),s=b(t.n,r.Fn,n),a=["Gx","Gy","a","weierstrass"===e?"b":"d"];for(const e of a)if(!o.isValid(t[e]))throw new Error(`CURVE.${e} must be valid field element of CURVE.Fp`);return{CURVE:t=Object.freeze(Object.assign({},t)),Fp:o,Fn:s}};const n=r(627),o=r(967),i=BigInt(0),s=BigInt(1);function a(e,t){const r=t.negate();return e?r:t}function c(e,t){if(!Number.isSafeInteger(e)||e<=0||e>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+e)}function f(e,t){c(e,t);const r=2**e;return{windows:Math.ceil(t/e)+1,windowSize:2**(e-1),mask:(0,n.bitMask)(e),maxNumber:r,shiftBy:BigInt(e)}}function u(e,t,r){const{windowSize:n,mask:o,maxNumber:i,shiftBy:a}=r;let c=Number(e&o),f=e>>a;c>n&&(c-=i,f+=s);const u=t*n;return{nextN:f,offset:u+Math.abs(c)-1,isZero:0===c,isNeg:c<0,isNegF:t%2!=0,offsetF:u}}function d(e,t){if(!Array.isArray(e))throw new Error("array expected");e.forEach((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)})}function l(e,t){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)})}const h=new WeakMap,p=new WeakMap;function w(e){return p.get(e)||1}function g(e){if(e!==i)throw new Error("invalid wNAF")}function b(e,t,r){if(t){if(t.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,o.validateField)(t),t}return(0,o.Field)(e,{isLE:r})}t.wNAF=class{constructor(e,t){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=t}_unsafeLadder(e,t,r=this.ZERO){let n=e;for(;t>i;)t&s&&(r=r.add(n)),n=n.double(),t>>=s;return r}precomputeWindow(e,t){const{windows:r,windowSize:n}=f(t,this.bits),o=[];let i=e,s=i;for(let e=0;e<r;e++){s=i,o.push(s);for(let e=1;e<n;e++)s=s.add(i),o.push(s);i=s.double()}return o}wNAF(e,t,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let n=this.ZERO,o=this.BASE;const i=f(e,this.bits);for(let e=0;e<i.windows;e++){const{nextN:s,offset:c,isZero:f,isNeg:d,isNegF:l,offsetF:h}=u(r,e,i);r=s,f?o=o.add(a(l,t[h])):n=n.add(a(d,t[c]))}return g(r),{p:n,f:o}}wNAFUnsafe(e,t,r,n=this.ZERO){const o=f(e,this.bits);for(let e=0;e<o.windows&&r!==i;e++){const{nextN:i,offset:s,isZero:a,isNeg:c}=u(r,e,o);if(r=i,!a){const e=t[s];n=n.add(c?e.negate():e)}}return g(r),n}getPrecomputes(e,t,r){let n=h.get(t);return n||(n=this.precomputeWindow(t,e),1!==e&&("function"==typeof r&&(n=r(n)),h.set(t,n))),n}cached(e,t,r){const n=w(e);return this.wNAF(n,this.getPrecomputes(n,e,r),t)}unsafe(e,t,r,n){const o=w(e);return 1===o?this._unsafeLadder(e,t,n):this.wNAFUnsafe(o,this.getPrecomputes(o,e,r),t,n)}createCache(e,t){c(t,this.bits),p.set(e,t),h.delete(e)}hasCache(e){return 1!==w(e)}}},761(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t._DST_scalar=void 0,t.expand_message_xmd=u,t.expand_message_xof=d,t.hash_to_field=l,t.isogenyMap=function(e,t){const r=t.map(e=>Array.from(e).reverse());return(t,n)=>{const[i,s,a,c]=r.map(r=>r.reduce((r,n)=>e.add(e.mul(r,t),n))),[f,u]=(0,o.FpInvertBatch)(e,[s,c],!0);return t=e.mul(i,f),n=e.mul(n,e.mul(a,u)),{x:t,y:n}}},t.createHasher=function(e,r,n){if("function"!=typeof r)throw new Error("mapToCurve() must be defined");function o(t){return e.fromAffine(r(t))}function i(t){const r=t.clearCofactor();return r.equals(e.ZERO)?e.ZERO:(r.assertValidity(),r)}return{defaults:n,hashToCurve(e,t){const r=l(e,2,Object.assign({},n,t)),s=o(r[0]),a=o(r[1]);return i(s.add(a))},encodeToCurve(e,t){const r=n.encodeDST?{DST:n.encodeDST}:{};return i(o(l(e,1,Object.assign({},n,r,t))[0]))},mapToCurve(e){if(!Array.isArray(e))throw new Error("expected array of bigints");for(const t of e)if("bigint"!=typeof t)throw new Error("expected array of bigints");return i(o(e))},hashToScalar(r,o){const i=e.Fn.ORDER;return l(r,1,Object.assign({},n,{p:i,m:1,DST:t._DST_scalar},o))[0][0]}}};const n=r(627),o=r(967),i=n.bytesToNumberBE;function s(e,t){if(c(e),c(t),e<0||e>=1<<8*t)throw new Error("invalid I2OSP input: "+e);const r=Array.from({length:t}).fill(0);for(let n=t-1;n>=0;n--)r[n]=255&e,e>>>=8;return new Uint8Array(r)}function a(e,t){const r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e[n]^t[n];return r}function c(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function f(e){if(!(0,n.isBytes)(e)&&"string"!=typeof e)throw new Error("DST must be Uint8Array or string");return"string"==typeof e?(0,n.utf8ToBytes)(e):e}function u(e,t,r,o){(0,n.abytes)(e),c(r),(t=f(t)).length>255&&(t=o((0,n.concatBytes)((0,n.utf8ToBytes)("H2C-OVERSIZE-DST-"),t)));const{outputLen:i,blockLen:u}=o,d=Math.ceil(r/i);if(r>65535||d>255)throw new Error("expand_message_xmd: invalid lenInBytes");const l=(0,n.concatBytes)(t,s(t.length,1)),h=s(0,u),p=s(r,2),w=new Array(d),g=o((0,n.concatBytes)(h,e,p,s(0,1),l));w[0]=o((0,n.concatBytes)(g,s(1,1),l));for(let e=1;e<=d;e++){const t=[a(g,w[e-1]),s(e+1,1),l];w[e]=o((0,n.concatBytes)(...t))}return(0,n.concatBytes)(...w).slice(0,r)}function d(e,t,r,o,i){if((0,n.abytes)(e),c(r),(t=f(t)).length>255){const e=Math.ceil(2*o/8);t=i.create({dkLen:e}).update((0,n.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest()}if(r>65535||t.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:r}).update(e).update(s(r,2)).update(t).update(s(t.length,1)).digest()}function l(e,t,r){(0,n._validateObject)(r,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:s,k:a,m:f,hash:l,expand:h,DST:p}=r;if(!(0,n.isHash)(r.hash))throw new Error("expected valid hash");(0,n.abytes)(e),c(t);const w=s.toString(2).length,g=Math.ceil((w+a)/8),b=t*f*g;let m;if("xmd"===h)m=u(e,p,b,l);else if("xof"===h)m=d(e,p,b,a,l);else{if("_internal_pass"!==h)throw new Error('expand must be "xmd" or "xof"');m=e}const y=new Array(t);for(let e=0;e<t;e++){const t=new Array(f);for(let r=0;r<f;r++){const n=g*(r+e*f),a=m.subarray(n,n+g);t[r]=(0,o.mod)(i(a),s)}y[e]=t}return y}t._DST_scalar=(0,n.utf8ToBytes)("HashToScalar-")}}]);