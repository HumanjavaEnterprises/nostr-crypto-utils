/*! For license information please see 761.nostr-crypto-utils.min.js.LICENSE.txt */
"use strict";(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[761],{1761:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.expand_message_xmd=f,t.expand_message_xof=c,t.hash_to_field=d,t.isogenyMap=function(e,t){const r=t.map((e=>Array.from(e).reverse()));return(t,n)=>{const[o,i,s,u]=r.map((r=>r.reduce(((r,n)=>e.add(e.mul(r,t),n)))));return t=e.div(o,i),n=e.mul(n,e.div(s,u)),{x:t,y:n}}},t.createHasher=function(e,t,r){if("function"!=typeof t)throw new Error("mapToCurve() must be defined");return{hashToCurve(n,o){const i=d(n,2,{...r,DST:r.DST,...o}),s=e.fromAffine(t(i[0])),u=e.fromAffine(t(i[1])),a=s.add(u).clearCofactor();return a.assertValidity(),a},encodeToCurve(n,o){const i=d(n,1,{...r,DST:r.encodeDST,...o}),s=e.fromAffine(t(i[0])).clearCofactor();return s.assertValidity(),s},mapToCurve(r){if(!Array.isArray(r))throw new Error("mapToCurve: expected array of bigints");for(const e of r)if("bigint"!=typeof e)throw new Error("mapToCurve: expected array of bigints");const n=e.fromAffine(t(r)).clearCofactor();return n.assertValidity(),n}}};const n=r(4967),o=r(1484),i=o.bytesToNumberBE;function s(e,t){if(a(e),a(t),e<0||e>=1<<8*t)throw new Error("invalid I2OSP input: "+e);const r=Array.from({length:t}).fill(0);for(let n=t-1;n>=0;n--)r[n]=255&e,e>>>=8;return new Uint8Array(r)}function u(e,t){const r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e[n]^t[n];return r}function a(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function f(e,t,r,n){(0,o.abytes)(e),(0,o.abytes)(t),a(r),t.length>255&&(t=n((0,o.concatBytes)((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-"),t)));const{outputLen:i,blockLen:f}=n,c=Math.ceil(r/i);if(r>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");const d=(0,o.concatBytes)(t,s(t.length,1)),l=s(0,f),h=s(r,2),p=new Array(c),g=n((0,o.concatBytes)(l,e,h,s(0,1),d));p[0]=n((0,o.concatBytes)(g,s(1,1),d));for(let e=1;e<=c;e++){const t=[u(g,p[e-1]),s(e+1,1),d];p[e]=n((0,o.concatBytes)(...t))}return(0,o.concatBytes)(...p).slice(0,r)}function c(e,t,r,n,i){if((0,o.abytes)(e),(0,o.abytes)(t),a(r),t.length>255){const e=Math.ceil(2*n/8);t=i.create({dkLen:e}).update((0,o.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest()}if(r>65535||t.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:r}).update(e).update(s(r,2)).update(t).update(s(t.length,1)).digest()}function d(e,t,r){(0,o.validateObject)(r,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:s,k:u,m:d,hash:l,expand:h,DST:p}=r;(0,o.abytes)(e),a(t);const g="string"==typeof p?(0,o.utf8ToBytes)(p):p,w=s.toString(2).length,y=Math.ceil((w+u)/8),m=t*d*y;let E;if("xmd"===h)E=f(e,g,m,l);else if("xof"===h)E=c(e,g,m,u,l);else{if("_internal_pass"!==h)throw new Error('expand must be "xmd" or "xof"');E=e}const b=new Array(t);for(let e=0;e<t;e++){const t=new Array(d);for(let r=0;r<d;r++){const o=y*(r+e*d),u=E.subarray(o,o+y);t[r]=(0,n.mod)(i(u),s)}b[e]=t}return b}},4967:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isNegativeLE=void 0,t.mod=d,t.pow=l,t.pow2=function(e,t,r){let n=e;for(;t-- >o;)n*=n,n%=r;return n},t.invert=h,t.tonelliShanks=p,t.FpSqrt=g,t.validateField=function(e){const t=w.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,n.validateObject)(e,t)},t.FpPow=y,t.FpInvertBatch=m,t.FpDiv=function(e,t,r){return e.mul(t,"bigint"==typeof r?h(r,e.ORDER):e.inv(r))},t.FpLegendre=E,t.FpIsSquare=function(e){const t=E(e.ORDER);return r=>{const n=t(e,r);return e.eql(n,e.ZERO)||e.eql(n,e.ONE)}},t.nLength=b,t.Field=function(e,t,r=!1,s={}){if(e<=o)throw new Error("invalid field: expected ORDER > 0, got "+e);const{nBitLength:u,nByteLength:a}=b(e,t);if(a>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const c=Object.freeze({ORDER:e,BITS:u,BYTES:a,MASK:(0,n.bitMask)(u),ZERO:o,ONE:i,create:t=>d(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return o<=t&&t<e},is0:e=>e===o,isOdd:e=>(e&i)===i,neg:t=>d(-t,e),eql:(e,t)=>e===t,sqr:t=>d(t*t,e),add:(t,r)=>d(t+r,e),sub:(t,r)=>d(t-r,e),mul:(t,r)=>d(t*r,e),pow:(e,t)=>y(c,e,t),div:(t,r)=>d(t*h(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>h(t,e),sqrt:s.sqrt||(t=>(f||(f=g(e)),f(c,t))),invertBatch:e=>m(c,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?(0,n.numberToBytesLE)(e,a):(0,n.numberToBytesBE)(e,a),fromBytes:e=>{if(e.length!==a)throw new Error("Field.fromBytes: expected "+a+" bytes, got "+e.length);return r?(0,n.bytesToNumberLE)(e):(0,n.bytesToNumberBE)(e)}});return Object.freeze(c)},t.FpSqrtOdd=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?r:e.neg(r)},t.FpSqrtEven=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?e.neg(r):r},t.hashToPrivateScalar=function(e,t,r=!1){const o=(e=(0,n.ensureBytes)("privateHash",e)).length,s=b(t).nByteLength+8;if(s<24||o<s||o>1024)throw new Error("hashToPrivateScalar: expected "+s+"-1024 bytes of input, got "+o);return d(r?(0,n.bytesToNumberLE)(e):(0,n.bytesToNumberBE)(e),t-i)+i},t.getFieldBytesLength=v,t.getMinHashLength=B,t.mapHashToField=function(e,t,r=!1){const o=e.length,s=v(t),u=B(t);if(o<16||o<u||o>1024)throw new Error("expected "+u+"-1024 bytes of input, got "+o);const a=d(r?(0,n.bytesToNumberBE)(e):(0,n.bytesToNumberLE)(e),t-i)+i;return r?(0,n.numberToBytesLE)(a,s):(0,n.numberToBytesBE)(a,s)};const n=r(1484),o=BigInt(0),i=BigInt(1),s=BigInt(2),u=BigInt(3),a=BigInt(4),f=BigInt(5),c=BigInt(8);function d(e,t){const r=e%t;return r>=o?r:t+r}function l(e,t,r){if(t<o)throw new Error("invalid exponent, negatives unsupported");if(r<=o)throw new Error("invalid modulus");if(r===i)return o;let n=i;for(;t>o;)t&i&&(n=n*e%r),e=e*e%r,t>>=i;return n}function h(e,t){if(e===o)throw new Error("invert: expected non-zero number");if(t<=o)throw new Error("invert: expected positive modulus, got "+t);let r=d(e,t),n=t,s=o,u=i,a=i,f=o;for(;r!==o;){const e=n/r,t=n%r,o=s-a*e,i=u-f*e;n=r,r=t,s=a,u=f,a=o,f=i}if(n!==i)throw new Error("invert: does not exist");return d(s,t)}function p(e){const t=(e-i)/s;let r,n,u;for(r=e-i,n=0;r%s===o;r/=s,n++);for(u=s;u<e&&l(u,t,e)!==e-i;u++)if(u>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===n){const t=(e+i)/a;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const f=(r+i)/s;return function(e,o){if(e.pow(o,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let s=n,a=e.pow(e.mul(e.ONE,u),r),c=e.pow(o,f),d=e.pow(o,r);for(;!e.eql(d,e.ONE);){if(e.eql(d,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(d);t<s&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(a,i<<BigInt(s-t-1));a=e.sqr(r),c=e.mul(c,r),d=e.mul(d,a),s=t}return c}}function g(e){if(e%a===u){const t=(e+i)/a;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%c===f){const t=(e-f)/c;return function(e,r){const n=e.mul(r,s),o=e.pow(n,t),i=e.mul(r,o),u=e.mul(e.mul(i,s),o),a=e.mul(i,e.sub(u,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return p(e)}t.isNegativeLE=(e,t)=>(d(e,t)&i)===i;const w=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function y(e,t,r){if(r<o)throw new Error("invalid exponent, negatives unsupported");if(r===o)return e.ONE;if(r===i)return t;let n=e.ONE,s=t;for(;r>o;)r&i&&(n=e.mul(n,s)),s=e.sqr(s),r>>=i;return n}function m(e,t){const r=new Array(t.length),n=t.reduce(((t,n,o)=>e.is0(n)?t:(r[o]=t,e.mul(t,n))),e.ONE),o=e.inv(n);return t.reduceRight(((t,n,o)=>e.is0(n)?t:(r[o]=e.mul(t,r[o]),e.mul(t,n))),o),r}function E(e){const t=(e-i)/s;return(e,r)=>e.pow(r,t)}function b(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function v(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function B(e){const t=v(e);return t+Math.ceil(t/2)}}}]);