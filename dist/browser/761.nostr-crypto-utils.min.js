/*! For license information please see 761.nostr-crypto-utils.min.js.LICENSE.txt */
"use strict";(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[761],{1761(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t._DST_scalar=void 0,t.expand_message_xmd=l,t.expand_message_xof=f,t.hash_to_field=d,t.isogenyMap=function(e,t){const n=t.map(e=>Array.from(e).reverse());return(t,r)=>{const[i,s,u,a]=n.map(n=>n.reduce((n,r)=>e.add(e.mul(n,t),r))),[c,l]=(0,o.FpInvertBatch)(e,[s,a],!0);return t=e.mul(i,c),r=e.mul(r,e.mul(u,l)),{x:t,y:r}}},t.createHasher=function(e,n,r){if("function"!=typeof n)throw new Error("mapToCurve() must be defined");function o(t){return e.fromAffine(n(t))}function i(t){const n=t.clearCofactor();return n.equals(e.ZERO)?e.ZERO:(n.assertValidity(),n)}return{defaults:r,hashToCurve(e,t){const n=d(e,2,Object.assign({},r,t)),s=o(n[0]),u=o(n[1]);return i(s.add(u))},encodeToCurve(e,t){const n=r.encodeDST?{DST:r.encodeDST}:{};return i(o(d(e,1,Object.assign({},r,n,t))[0]))},mapToCurve(e){if(!Array.isArray(e))throw new Error("expected array of bigints");for(const t of e)if("bigint"!=typeof t)throw new Error("expected array of bigints");return i(o(e))},hashToScalar(n,o){const i=e.Fn.ORDER;return d(n,1,Object.assign({},r,{p:i,m:1,DST:t._DST_scalar},o))[0][0]}}};const r=n(8627),o=n(4967),i=r.bytesToNumberBE;function s(e,t){if(a(e),a(t),e<0||e>=1<<8*t)throw new Error("invalid I2OSP input: "+e);const n=Array.from({length:t}).fill(0);for(let r=t-1;r>=0;r--)n[r]=255&e,e>>>=8;return new Uint8Array(n)}function u(e,t){const n=new Uint8Array(e.length);for(let r=0;r<e.length;r++)n[r]=e[r]^t[r];return n}function a(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function c(e){if(!(0,r.isBytes)(e)&&"string"!=typeof e)throw new Error("DST must be Uint8Array or string");return"string"==typeof e?(0,r.utf8ToBytes)(e):e}function l(e,t,n,o){(0,r.abytes)(e),a(n),(t=c(t)).length>255&&(t=o((0,r.concatBytes)((0,r.utf8ToBytes)("H2C-OVERSIZE-DST-"),t)));const{outputLen:i,blockLen:l}=o,f=Math.ceil(n/i);if(n>65535||f>255)throw new Error("expand_message_xmd: invalid lenInBytes");const d=(0,r.concatBytes)(t,s(t.length,1)),h=s(0,l),g=s(n,2),w=new Array(f),p=o((0,r.concatBytes)(h,e,g,s(0,1),d));w[0]=o((0,r.concatBytes)(p,s(1,1),d));for(let e=1;e<=f;e++){const t=[u(p,w[e-1]),s(e+1,1),d];w[e]=o((0,r.concatBytes)(...t))}return(0,r.concatBytes)(...w).slice(0,n)}function f(e,t,n,o,i){if((0,r.abytes)(e),a(n),(t=c(t)).length>255){const e=Math.ceil(2*o/8);t=i.create({dkLen:e}).update((0,r.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest()}if(n>65535||t.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:n}).update(e).update(s(n,2)).update(t).update(s(t.length,1)).digest()}function d(e,t,n){(0,r._validateObject)(n,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:s,k:u,m:c,hash:d,expand:h,DST:g}=n;if(!(0,r.isHash)(n.hash))throw new Error("expected valid hash");(0,r.abytes)(e),a(t);const w=s.toString(2).length,p=Math.ceil((w+u)/8),m=t*c*p;let E;if("xmd"===h)E=l(e,g,m,d);else if("xof"===h)E=f(e,g,m,u,d);else{if("_internal_pass"!==h)throw new Error('expand must be "xmd" or "xof"');E=e}const y=new Array(t);for(let e=0;e<t;e++){const t=new Array(c);for(let n=0;n<c;n++){const r=p*(n+e*c),u=E.subarray(r,r+p);t[n]=(0,o.mod)(i(u),s)}y[e]=t}return y}t._DST_scalar=(0,r.utf8ToBytes)("HashToScalar-")},4967(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),t.isNegativeLE=void 0,t.mod=g,t.pow=function(e,t,n){return v(S(n),e,t)},t.pow2=function(e,t,n){let r=e;for(;t-- >o;)r*=r,r%=n;return r},t.invert=w,t.tonelliShanks=y,t.FpSqrt=b,t.validateField=function(e){const t=B.reduce((e,t)=>(e[t]="function",e),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,r._validateObject)(e,t),e},t.FpPow=v,t.FpInvertBatch=O,t.FpDiv=function(e,t,n){return e.mul(t,"bigint"==typeof n?w(n,e.ORDER):e.inv(n))},t.FpLegendre=q,t.FpIsSquare=function(e,t){return 1===q(e,t)},t.nLength=T,t.Field=S,t.FpSqrtOdd=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const n=e.sqrt(t);return e.isOdd(n)?n:e.neg(n)},t.FpSqrtEven=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const n=e.sqrt(t);return e.isOdd(n)?e.neg(n):n},t.hashToPrivateScalar=function(e,t,n=!1){const o=(e=(0,r.ensureBytes)("privateHash",e)).length,s=T(t).nByteLength+8;if(s<24||o<s||o>1024)throw new Error("hashToPrivateScalar: expected "+s+"-1024 bytes of input, got "+o);return g(n?(0,r.bytesToNumberLE)(e):(0,r.bytesToNumberBE)(e),t-i)+i},t.getFieldBytesLength=N,t.getMinHashLength=x,t.mapHashToField=function(e,t,n=!1){const o=e.length,s=N(t),u=x(t);if(o<16||o<u||o>1024)throw new Error("expected "+u+"-1024 bytes of input, got "+o);const a=g(n?(0,r.bytesToNumberLE)(e):(0,r.bytesToNumberBE)(e),t-i)+i;return n?(0,r.numberToBytesLE)(a,s):(0,r.numberToBytesBE)(a,s)};const r=n(8627),o=BigInt(0),i=BigInt(1),s=BigInt(2),u=BigInt(3),a=BigInt(4),c=BigInt(5),l=BigInt(7),f=BigInt(8),d=BigInt(9),h=BigInt(16);function g(e,t){const n=e%t;return n>=o?n:t+n}function w(e,t){if(e===o)throw new Error("invert: expected non-zero number");if(t<=o)throw new Error("invert: expected positive modulus, got "+t);let n=g(e,t),r=t,s=o,u=i,a=i,c=o;for(;n!==o;){const e=r/n,t=r%n,o=s-a*e,i=u-c*e;r=n,n=t,s=a,u=c,a=o,c=i}if(r!==i)throw new Error("invert: does not exist");return g(s,t)}function p(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function m(e,t){const n=(e.ORDER+i)/a,r=e.pow(t,n);return p(e,r,t),r}function E(e,t){const n=(e.ORDER-c)/f,r=e.mul(t,s),o=e.pow(r,n),i=e.mul(t,o),u=e.mul(e.mul(i,s),o),a=e.mul(i,e.sub(u,e.ONE));return p(e,a,t),a}function y(e){if(e<u)throw new Error("sqrt is not defined for small field");let t=e-i,n=0;for(;t%s===o;)t/=s,n++;let r=s;const a=S(e);for(;1===q(a,r);)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===n)return m;let c=a.pow(r,t);const l=(t+i)/s;return function(e,r){if(e.is0(r))return r;if(1!==q(e,r))throw new Error("Cannot find square root");let o=n,s=e.mul(e.ONE,c),u=e.pow(r,t),a=e.pow(r,l);for(;!e.eql(u,e.ONE);){if(e.is0(u))return e.ZERO;let t=1,n=e.sqr(u);for(;!e.eql(n,e.ONE);)if(t++,n=e.sqr(n),t===o)throw new Error("Cannot find square root");const r=i<<BigInt(o-t-1),c=e.pow(s,r);o=t,s=e.sqr(c),u=e.mul(u,s),a=e.mul(a,c)}return a}}function b(e){return e%a===u?m:e%f===c?E:e%h===d?function(e){const t=S(e),n=y(e),r=n(t,t.neg(t.ONE)),o=n(t,r),i=n(t,t.neg(r)),s=(e+l)/h;return(e,t)=>{let n=e.pow(t,s),u=e.mul(n,r);const a=e.mul(n,o),c=e.mul(n,i),l=e.eql(e.sqr(u),t),f=e.eql(e.sqr(a),t);n=e.cmov(n,u,l),u=e.cmov(c,a,f);const d=e.eql(e.sqr(u),t),h=e.cmov(n,u,d);return p(e,h,t),h}}(e):y(e)}t.isNegativeLE=(e,t)=>(g(e,t)&i)===i;const B=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function v(e,t,n){if(n<o)throw new Error("invalid exponent, negatives unsupported");if(n===o)return e.ONE;if(n===i)return t;let r=e.ONE,s=t;for(;n>o;)n&i&&(r=e.mul(r,s)),s=e.sqr(s),n>>=i;return r}function O(e,t,n=!1){const r=new Array(t.length).fill(n?e.ZERO:void 0),o=t.reduce((t,n,o)=>e.is0(n)?t:(r[o]=t,e.mul(t,n)),e.ONE),i=e.inv(o);return t.reduceRight((t,n,o)=>e.is0(n)?t:(r[o]=e.mul(t,r[o]),e.mul(t,n)),i),r}function q(e,t){const n=(e.ORDER-i)/s,r=e.pow(t,n),o=e.eql(r,e.ONE),u=e.eql(r,e.ZERO),a=e.eql(r,e.neg(e.ONE));if(!o&&!u&&!a)throw new Error("invalid Legendre symbol result");return o?1:u?0:-1}function T(e,t){void 0!==t&&(0,r.anumber)(t);const n=void 0!==t?t:e.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function S(e,t,n=!1,s={}){if(e<=o)throw new Error("invalid field: expected ORDER > 0, got "+e);let u,a,c,l=!1;if("object"==typeof t&&null!=t){if(s.sqrt||n)throw new Error("cannot specify opts in two arguments");const e=t;e.BITS&&(u=e.BITS),e.sqrt&&(a=e.sqrt),"boolean"==typeof e.isLE&&(n=e.isLE),"boolean"==typeof e.modFromBytes&&(l=e.modFromBytes),c=e.allowedLengths}else"number"==typeof t&&(u=t),s.sqrt&&(a=s.sqrt);const{nBitLength:f,nByteLength:d}=T(e,u);if(d>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let h;const p=Object.freeze({ORDER:e,isLE:n,BITS:f,BYTES:d,MASK:(0,r.bitMask)(f),ZERO:o,ONE:i,allowedLengths:c,create:t=>g(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("invalid field element: expected bigint, got "+typeof t);return o<=t&&t<e},is0:e=>e===o,isValidNot0:e=>!p.is0(e)&&p.isValid(e),isOdd:e=>(e&i)===i,neg:t=>g(-t,e),eql:(e,t)=>e===t,sqr:t=>g(t*t,e),add:(t,n)=>g(t+n,e),sub:(t,n)=>g(t-n,e),mul:(t,n)=>g(t*n,e),pow:(e,t)=>v(p,e,t),div:(t,n)=>g(t*w(n,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>w(t,e),sqrt:a||(t=>(h||(h=b(e)),h(p,t))),toBytes:e=>n?(0,r.numberToBytesLE)(e,d):(0,r.numberToBytesBE)(e,d),fromBytes:(t,o=!0)=>{if(c){if(!c.includes(t.length)||t.length>d)throw new Error("Field.fromBytes: expected "+c+" bytes, got "+t.length);const e=new Uint8Array(d);e.set(t,n?0:e.length-t.length),t=e}if(t.length!==d)throw new Error("Field.fromBytes: expected "+d+" bytes, got "+t.length);let i=n?(0,r.bytesToNumberLE)(t):(0,r.bytesToNumberBE)(t);if(l&&(i=g(i,e)),!o&&!p.isValid(i))throw new Error("invalid field element: outside of range 0..ORDER");return i},invertBatch:e=>O(p,e),cmov:(e,t,n)=>n?t:e});return Object.freeze(p)}function N(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function x(e){const t=N(e);return t+Math.ceil(t/2)}}}]);