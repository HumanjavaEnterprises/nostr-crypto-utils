/*! For license information please see 705.nostr-crypto-utils.min.js.LICENSE.txt */
"use strict";(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[705],{1705(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),t.DER=t.DERErr=void 0,t._splitEndoScalar=u,t._normFnElement=g,t.weierstrassN=b,t.SWUFpSqrtRatio=v,t.mapToCurveSimpleSWU=function(e,t){(0,a.validateField)(e);const{A:r,B:n,Z:o}=t;if(!e.isValid(r)||!e.isValid(n)||!e.isValid(o))throw new Error("mapToCurveSimpleSWU: invalid opts");const s=v(e,o);if(!e.isOdd)throw new Error("Field does not have .isOdd()");return t=>{let i,c,u,l,d,f,m,y;i=e.sqr(t),i=e.mul(i,o),c=e.sqr(i),c=e.add(c,i),u=e.add(c,e.ONE),u=e.mul(u,n),l=e.cmov(o,e.neg(c),!e.eql(c,e.ZERO)),l=e.mul(l,r),c=e.sqr(u),f=e.sqr(l),d=e.mul(f,r),c=e.add(c,d),c=e.mul(c,u),f=e.mul(f,l),d=e.mul(f,n),c=e.add(c,d),m=e.mul(i,u);const{isValid:h,value:p}=s(c,f);y=e.mul(i,t),y=e.mul(y,p),m=e.cmov(m,u,h),y=e.cmov(y,p,h);const w=e.isOdd(t)===e.isOdd(y);y=e.cmov(e.neg(y),y,w);const g=(0,a.FpInvertBatch)(e,[l],!0)[0];return m=e.mul(m,g),{x:m,y}}},t.ecdh=R,t.ecdsa=O,t.weierstrassPoints=function(e){const{CURVE:t,curveOpts:r}=S(e);return function(e,t){const{Fp:r,Fn:n}=t;const o=x(r,e.a,e.b);return Object.assign({},{CURVE:e,Point:t,ProjectivePoint:t,normPrivateKeyToScalar:e=>g(n,e),weierstrassEquation:o,isWithinCurveOrder:function(e){return(0,s.inRange)(e,y,n.ORDER)}})}(e,b(t,r))},t._legacyHelperEquat=x,t.weierstrass=function(e){const{CURVE:t,curveOpts:r,hash:n,ecdsaOpts:o}=function(e){const{CURVE:t,curveOpts:r}=S(e),n={hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:t,curveOpts:r,hash:e.hash,ecdsaOpts:n}}(e);return function(e,t){const r=t.Point;return Object.assign({},t,{ProjectivePoint:r,CURVE:Object.assign({},e,(0,a.nLength)(r.Fn.ORDER,r.Fn.BITS))})}(e,O(b(t,r),n,o))};const n=r(9615),o=r(9175),s=r(8627),i=r(2422),a=r(4967),c=(e,t)=>(e+(e>=0?t:-t)/h)/t;function u(e,t,r){const[[n,o],[i,a]]=t,u=c(a*e,r),l=c(-o*e,r);let d=e-u*n-l*i,f=-u*o-l*a;const h=d<m,p=f<m;h&&(d=-d),p&&(f=-f);const w=(0,s.bitMask)(Math.ceil((0,s.bitLen)(r)/2))+y;if(d<m||d>=w||f<m||f>=w)throw new Error("splitScalar (endomorphism): failed, k="+e);return{k1neg:h,k1:d,k2neg:p,k2:f}}function l(e){if(!["compact","recovered","der"].includes(e))throw new Error('Signature format must be "compact", "recovered", or "der"');return e}function d(e,t){const r={};for(let n of Object.keys(t))r[n]=void 0===e[n]?t[n]:e[n];return(0,s._abool2)(r.lowS,"lowS"),(0,s._abool2)(r.prehash,"prehash"),void 0!==r.format&&l(r.format),r}class f extends Error{constructor(e=""){super(e)}}t.DERErr=f,t.DER={Err:f,_tlv:{encode:(e,r)=>{const{Err:n}=t.DER;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(1&r.length)throw new n("tlv.encode: unpadded data");const o=r.length/2,i=(0,s.numberToHexUnpadded)(o);if(i.length/2&128)throw new n("tlv.encode: long form length too big");const a=o>127?(0,s.numberToHexUnpadded)(i.length/2|128):"";return(0,s.numberToHexUnpadded)(e)+a+i+r},decode(e,r){const{Err:n}=t.DER;let o=0;if(e<0||e>256)throw new n("tlv.encode: wrong tag");if(r.length<2||r[o++]!==e)throw new n("tlv.decode: wrong tlv");const s=r[o++];let i=0;if(128&s){const e=127&s;if(!e)throw new n("tlv.decode(long): indefinite length not supported");if(e>4)throw new n("tlv.decode(long): byte length is too big");const t=r.subarray(o,o+e);if(t.length!==e)throw new n("tlv.decode: length bytes not complete");if(0===t[0])throw new n("tlv.decode(long): zero leftmost byte");for(const e of t)i=i<<8|e;if(o+=e,i<128)throw new n("tlv.decode(long): not minimal encoding")}else i=s;const a=r.subarray(o,o+i);if(a.length!==i)throw new n("tlv.decode: wrong value length");return{v:a,l:r.subarray(o+i)}}},_int:{encode(e){const{Err:r}=t.DER;if(e<m)throw new r("integer: negative integers are not allowed");let n=(0,s.numberToHexUnpadded)(e);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new r("unexpected DER parsing assertion: unpadded hex");return n},decode(e){const{Err:r}=t.DER;if(128&e[0])throw new r("invalid signature integer: negative");if(0===e[0]&&!(128&e[1]))throw new r("invalid signature integer: unnecessary leading zero");return(0,s.bytesToNumberBE)(e)}},toSig(e){const{Err:r,_int:n,_tlv:o}=t.DER,i=(0,s.ensureBytes)("signature",e),{v:a,l:c}=o.decode(48,i);if(c.length)throw new r("invalid signature: left bytes after parsing");const{v:u,l}=o.decode(2,a),{v:d,l:f}=o.decode(2,l);if(f.length)throw new r("invalid signature: left bytes after parsing");return{r:n.decode(u),s:n.decode(d)}},hexFromSig(e){const{_tlv:r,_int:n}=t.DER,o=r.encode(2,n.encode(e.r))+r.encode(2,n.encode(e.s));return r.encode(48,o)}};const m=BigInt(0),y=BigInt(1),h=BigInt(2),p=BigInt(3),w=BigInt(4);function g(e,t){const{BYTES:r}=e;let n;if("bigint"==typeof t)n=t;else{let o=(0,s.ensureBytes)("private key",t);try{n=e.fromBytes(o)}catch(e){throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof t}`)}}if(!e.isValidNot0(n))throw new Error("invalid private key: out of range [1..N-1]");return n}function b(e,t={}){const r=(0,i._createCurveFields)("weierstrass",e,t),{Fp:n,Fn:o}=r;let a=r.CURVE;const{h:c,n:l}=a;(0,s._validateObject)(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:d}=t;if(d&&(!n.is0(a.a)||"bigint"!=typeof d.beta||!Array.isArray(d.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const f=B(n,o);function h(){if(!n.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}const b=t.toBytes||function(e,t,r){const{x:o,y:i}=t.toAffine(),a=n.toBytes(o);if((0,s._abool2)(r,"isCompressed"),r){h();const e=!n.isOdd(i);return(0,s.concatBytes)(E(e),a)}return(0,s.concatBytes)(Uint8Array.of(4),a,n.toBytes(i))},v=t.fromBytes||function(e){(0,s._abytes2)(e,void 0,"Point");const{publicKey:t,publicKeyUncompressed:r}=f,o=e.length,i=e[0],a=e.subarray(1);if(o!==t||2!==i&&3!==i){if(o===r&&4===i){const e=n.BYTES,t=n.fromBytes(a.subarray(0,e)),r=n.fromBytes(a.subarray(e,2*e));if(!O(t,r))throw new Error("bad point: is not on curve");return{x:t,y:r}}throw new Error(`bad point: got length ${o}, expected compressed=${t} or uncompressed=${r}`)}{const e=n.fromBytes(a);if(!n.isValid(e))throw new Error("bad point: is not on curve, wrong x");const t=R(e);let r;try{r=n.sqrt(t)}catch(e){const t=e instanceof Error?": "+e.message:"";throw new Error("bad point: is not on curve, sqrt error"+t)}return h(),!(1&~i)!==n.isOdd(r)&&(r=n.neg(r)),{x:e,y:r}}};function R(e){const t=n.sqr(e),r=n.mul(t,e);return n.add(n.add(r,n.mul(e,a.a)),a.b)}function O(e,t){const r=n.sqr(t),o=R(e);return n.eql(r,o)}if(!O(a.Gx,a.Gy))throw new Error("bad curve params: generator point");const S=n.mul(n.pow(a.a,p),w),x=n.mul(n.sqr(a.b),BigInt(27));if(n.is0(n.add(S,x)))throw new Error("bad curve params: a or b");function F(e,t,r=!1){if(!n.isValid(t)||r&&n.is0(t))throw new Error(`bad point coordinate ${e}`);return t}function U(e){if(!(e instanceof Z))throw new Error("ProjectivePoint expected")}function P(e){if(!d||!d.basises)throw new Error("no endo");return u(e,d.basises,o.ORDER)}const T=(0,s.memoized)((e,t)=>{const{X:r,Y:o,Z:s}=e;if(n.eql(s,n.ONE))return{x:r,y:o};const i=e.is0();null==t&&(t=i?n.ONE:n.inv(s));const a=n.mul(r,t),c=n.mul(o,t),u=n.mul(s,t);if(i)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),V=(0,s.memoized)(e=>{if(e.is0()){if(t.allowInfinityPoint&&!n.is0(e.Y))return;throw new Error("bad point: ZERO")}const{x:r,y:o}=e.toAffine();if(!n.isValid(r)||!n.isValid(o))throw new Error("bad point: x or y not field elements");if(!O(r,o))throw new Error("bad point: equation left != right");if(!e.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function K(e,t,r,o,s){return r=new Z(n.mul(r.X,e),r.Y,r.Z),t=(0,i.negateCt)(o,t),r=(0,i.negateCt)(s,r),t.add(r)}class Z{constructor(e,t,r){this.X=F("x",e),this.Y=F("y",t,!0),this.Z=F("z",r),Object.freeze(this)}static CURVE(){return a}static fromAffine(e){const{x:t,y:r}=e||{};if(!e||!n.isValid(t)||!n.isValid(r))throw new Error("invalid affine point");if(e instanceof Z)throw new Error("projective point not allowed");return n.is0(t)&&n.is0(r)?Z.ZERO:new Z(t,r,n.ONE)}static fromBytes(e){const t=Z.fromAffine(v((0,s._abytes2)(e,void 0,"point")));return t.assertValidity(),t}static fromHex(e){return Z.fromBytes((0,s.ensureBytes)("pointHex",e))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(e=8,t=!0){return C.createCache(this,e),t||this.multiply(p),this}assertValidity(){V(this)}hasEvenY(){const{y:e}=this.toAffine();if(!n.isOdd)throw new Error("Field doesn't support isOdd");return!n.isOdd(e)}equals(e){U(e);const{X:t,Y:r,Z:o}=this,{X:s,Y:i,Z:a}=e,c=n.eql(n.mul(t,a),n.mul(s,o)),u=n.eql(n.mul(r,a),n.mul(i,o));return c&&u}negate(){return new Z(this.X,n.neg(this.Y),this.Z)}double(){const{a:e,b:t}=a,r=n.mul(t,p),{X:o,Y:s,Z:i}=this;let c=n.ZERO,u=n.ZERO,l=n.ZERO,d=n.mul(o,o),f=n.mul(s,s),m=n.mul(i,i),y=n.mul(o,s);return y=n.add(y,y),l=n.mul(o,i),l=n.add(l,l),c=n.mul(e,l),u=n.mul(r,m),u=n.add(c,u),c=n.sub(f,u),u=n.add(f,u),u=n.mul(c,u),c=n.mul(y,c),l=n.mul(r,l),m=n.mul(e,m),y=n.sub(d,m),y=n.mul(e,y),y=n.add(y,l),l=n.add(d,d),d=n.add(l,d),d=n.add(d,m),d=n.mul(d,y),u=n.add(u,d),m=n.mul(s,i),m=n.add(m,m),d=n.mul(m,y),c=n.sub(c,d),l=n.mul(m,f),l=n.add(l,l),l=n.add(l,l),new Z(c,u,l)}add(e){U(e);const{X:t,Y:r,Z:o}=this,{X:s,Y:i,Z:c}=e;let u=n.ZERO,l=n.ZERO,d=n.ZERO;const f=a.a,m=n.mul(a.b,p);let y=n.mul(t,s),h=n.mul(r,i),w=n.mul(o,c),g=n.add(t,r),b=n.add(s,i);g=n.mul(g,b),b=n.add(y,h),g=n.sub(g,b),b=n.add(t,o);let E=n.add(s,c);return b=n.mul(b,E),E=n.add(y,w),b=n.sub(b,E),E=n.add(r,o),u=n.add(i,c),E=n.mul(E,u),u=n.add(h,w),E=n.sub(E,u),d=n.mul(f,b),u=n.mul(m,w),d=n.add(u,d),u=n.sub(h,d),d=n.add(h,d),l=n.mul(u,d),h=n.add(y,y),h=n.add(h,y),w=n.mul(f,w),b=n.mul(m,b),h=n.add(h,w),w=n.sub(y,w),w=n.mul(f,w),b=n.add(b,w),y=n.mul(h,b),l=n.add(l,y),y=n.mul(E,b),u=n.mul(g,u),u=n.sub(u,y),y=n.mul(g,h),d=n.mul(E,d),d=n.add(d,y),new Z(u,l,d)}subtract(e){return this.add(e.negate())}is0(){return this.equals(Z.ZERO)}multiply(e){const{endo:r}=t;if(!o.isValidNot0(e))throw new Error("invalid scalar: out of range");let n,s;const a=e=>C.cached(this,e,e=>(0,i.normalizeZ)(Z,e));if(r){const{k1neg:t,k1:o,k2neg:i,k2:c}=P(e),{p:u,f:l}=a(o),{p:d,f}=a(c);s=l.add(f),n=K(r.beta,u,d,t,i)}else{const{p:t,f:r}=a(e);n=t,s=r}return(0,i.normalizeZ)(Z,[n,s])[0]}multiplyUnsafe(e){const{endo:r}=t,n=this;if(!o.isValid(e))throw new Error("invalid scalar: out of range");if(e===m||n.is0())return Z.ZERO;if(e===y)return n;if(C.hasCache(this))return this.multiply(e);if(r){const{k1neg:t,k1:o,k2neg:s,k2:a}=P(e),{p1:c,p2:u}=(0,i.mulEndoUnsafe)(Z,n,o,a);return K(r.beta,c,u,t,s)}return C.unsafe(n,e)}multiplyAndAddUnsafe(e,t,r){const n=this.multiplyUnsafe(t).add(e.multiplyUnsafe(r));return n.is0()?void 0:n}toAffine(e){return T(this,e)}isTorsionFree(){const{isTorsionFree:e}=t;return c===y||(e?e(Z,this):C.unsafe(this,l).is0())}clearCofactor(){const{clearCofactor:e}=t;return c===y?this:e?e(Z,this):this.multiplyUnsafe(c)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}toBytes(e=!0){return(0,s._abool2)(e,"isCompressed"),this.assertValidity(),b(Z,this,e)}toHex(e=!0){return(0,s.bytesToHex)(this.toBytes(e))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(e=!0){return this.toBytes(e)}_setWindowSize(e){this.precompute(e)}static normalizeZ(e){return(0,i.normalizeZ)(Z,e)}static msm(e,t){return(0,i.pippenger)(Z,o,e,t)}static fromPrivateKey(e){return Z.BASE.multiply(g(o,e))}}Z.BASE=new Z(a.Gx,a.Gy,n.ONE),Z.ZERO=new Z(n.ZERO,n.ONE,n.ZERO),Z.Fp=n,Z.Fn=o;const k=o.BITS,C=new i.wNAF(Z,t.endo?Math.ceil(k/2):k);return Z.BASE.precompute(8),Z}function E(e){return Uint8Array.of(e?2:3)}function v(e,t){const r=e.ORDER;let n=m;for(let e=r-y;e%h===m;e/=h)n+=y;const o=n,s=h<<o-y-y,i=s*h,a=(r-y)/i,c=(a-y)/h,u=i-y,l=s,d=e.pow(t,a),f=e.pow(t,(a+y)/h);let g=(t,r)=>{let n=d,s=e.pow(r,u),i=e.sqr(s);i=e.mul(i,r);let a=e.mul(t,i);a=e.pow(a,c),a=e.mul(a,s),s=e.mul(a,r),i=e.mul(a,t);let m=e.mul(i,s);a=e.pow(m,l);let p=e.eql(a,e.ONE);s=e.mul(i,f),a=e.mul(m,n),i=e.cmov(s,i,p),m=e.cmov(a,m,p);for(let t=o;t>y;t--){let r=t-h;r=h<<r-y;let o=e.pow(m,r);const a=e.eql(o,e.ONE);s=e.mul(i,n),n=e.mul(n,n),o=e.mul(m,n),i=e.cmov(s,i,a),m=e.cmov(o,m,a)}return{isValid:p,value:i}};if(e.ORDER%w===p){const r=(e.ORDER-p)/w,n=e.sqrt(e.neg(t));g=(t,o)=>{let s=e.sqr(o);const i=e.mul(t,o);s=e.mul(s,i);let a=e.pow(s,r);a=e.mul(a,i);const c=e.mul(a,n),u=e.mul(e.sqr(a),o),l=e.eql(u,t);return{isValid:l,value:e.cmov(c,a,l)}}}return g}function B(e,t){return{secretKey:t.BYTES,publicKey:1+e.BYTES,publicKeyUncompressed:1+2*e.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function R(e,t={}){const{Fn:r}=e,n=t.randomBytes||s.randomBytes,o=Object.assign(B(e.Fp,r),{seed:(0,a.getMinHashLength)(r.ORDER)});function i(e){try{return!!g(r,e)}catch(e){return!1}}function c(e=n(o.seed)){return(0,a.mapHashToField)((0,s._abytes2)(e,o.seed,"seed"),r.ORDER)}function u(t,n=!0){return e.BASE.multiply(g(r,t)).toBytes(n)}function l(t){if("bigint"==typeof t)return!1;if(t instanceof e)return!0;const{secretKey:n,publicKey:i,publicKeyUncompressed:a}=o;if(r.allowedLengths||n===i)return;const c=(0,s.ensureBytes)("key",t).length;return c===i||c===a}const d={isValidSecretKey:i,isValidPublicKey:function(t,r){const{publicKey:n,publicKeyUncompressed:s}=o;try{const o=t.length;return!(!0===r&&o!==n||!1===r&&o!==s||!e.fromBytes(t))}catch(e){return!1}},randomSecretKey:c,isValidPrivateKey:i,randomPrivateKey:c,normPrivateKeyToScalar:e=>g(r,e),precompute:(t=8,r=e.BASE)=>r.precompute(t,!1)};return Object.freeze({getPublicKey:u,getSharedSecret:function(t,n,o=!0){if(!0===l(t))throw new Error("first arg must be private key");if(!1===l(n))throw new Error("second arg must be public key");const s=g(r,t);return e.fromHex(n).multiply(s).toBytes(o)},keygen:function(e){const t=c(e);return{secretKey:t,publicKey:u(t)}},Point:e,utils:d,lengths:o})}function O(e,r,i={}){(0,o.ahash)(r),(0,s._validateObject)(i,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const a=i.randomBytes||s.randomBytes,c=i.hmac||((e,...t)=>(0,n.hmac)(r,e,(0,s.concatBytes)(...t))),{Fp:u,Fn:f}=e,{ORDER:p,BITS:w}=f,{keygen:b,getPublicKey:v,getSharedSecret:B,utils:O,lengths:S}=R(e,i),x={prehash:!1,lowS:"boolean"==typeof i.lowS&&i.lowS,format:void 0,extraEntropy:!1},F="compact";function U(e){return e>p>>y}function P(e,t){if(!f.isValidNot0(t))throw new Error(`invalid signature ${e}: out of range 1..Point.Fn.ORDER`);return t}class T{constructor(e,t,r){this.r=P("r",e),this.s=P("s",t),null!=r&&(this.recovery=r),Object.freeze(this)}static fromBytes(e,r=F){let n;if(function(e,t){l(t);const r=S.signature,n="compact"===t?r:"recovered"===t?r+1:void 0;(0,s._abytes2)(e,n,`${t} signature`)}(e,r),"der"===r){const{r,s:n}=t.DER.toSig((0,s._abytes2)(e));return new T(r,n)}"recovered"===r&&(n=e[0],r="compact",e=e.subarray(1));const o=f.BYTES,i=e.subarray(0,o),a=e.subarray(o,2*o);return new T(f.fromBytes(i),f.fromBytes(a),n)}static fromHex(e,t){return this.fromBytes((0,s.hexToBytes)(e),t)}addRecoveryBit(e){return new T(this.r,this.s,e)}recoverPublicKey(t){const r=u.ORDER,{r:n,s:o,recovery:i}=this;if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");if(p*h<r&&i>1)throw new Error("recovery id is ambiguous for h>1 curve");const a=2===i||3===i?n+p:n;if(!u.isValid(a))throw new Error("recovery id 2 or 3 invalid");const c=u.toBytes(a),l=e.fromBytes((0,s.concatBytes)(E(!(1&i)),c)),d=f.inv(a),m=K((0,s.ensureBytes)("msgHash",t)),y=f.create(-m*d),w=f.create(o*d),g=e.BASE.multiplyUnsafe(y).add(l.multiplyUnsafe(w));if(g.is0())throw new Error("point at infinify");return g.assertValidity(),g}hasHighS(){return U(this.s)}toBytes(e=F){if(l(e),"der"===e)return(0,s.hexToBytes)(t.DER.hexFromSig(this));const r=f.toBytes(this.r),n=f.toBytes(this.s);if("recovered"===e){if(null==this.recovery)throw new Error("recovery bit must be present");return(0,s.concatBytes)(Uint8Array.of(this.recovery),r,n)}return(0,s.concatBytes)(r,n)}toHex(e){return(0,s.bytesToHex)(this.toBytes(e))}assertValidity(){}static fromCompact(e){return T.fromBytes((0,s.ensureBytes)("sig",e),"compact")}static fromDER(e){return T.fromBytes((0,s.ensureBytes)("sig",e),"der")}normalizeS(){return this.hasHighS()?new T(this.r,f.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,s.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,s.bytesToHex)(this.toBytes("compact"))}}const V=i.bits2int||function(e){if(e.length>8192)throw new Error("input is too large");const t=(0,s.bytesToNumberBE)(e),r=8*e.length-w;return r>0?t>>BigInt(r):t},K=i.bits2int_modN||function(e){return f.create(V(e))},Z=(0,s.bitMask)(w);function k(e){return(0,s.aInRange)("num < 2^"+w,e,m,Z),f.toBytes(e)}function C(e,t){return(0,s._abytes2)(e,void 0,"message"),t?(0,s._abytes2)(r(e),void 0,"prehashed message"):e}return Object.freeze({keygen:b,getPublicKey:v,getSharedSecret:B,utils:O,lengths:S,Point:e,sign:function(t,n,o={}){t=(0,s.ensureBytes)("message",t);const{seed:i,k2sig:u}=function(t,r,n){if(["recovered","canonical"].some(e=>e in n))throw new Error("sign() legacy options not supported");const{lowS:o,prehash:i,extraEntropy:c}=d(n,x);t=C(t,i);const u=K(t),l=g(f,r),h=[k(l),k(u)];if(null!=c&&!1!==c){const e=!0===c?a(S.secretKey):c;h.push((0,s.ensureBytes)("extraEntropy",e))}const p=(0,s.concatBytes)(...h),w=u;return{seed:p,k2sig:function(t){const r=V(t);if(!f.isValidNot0(r))return;const n=f.inv(r),s=e.BASE.multiply(r).toAffine(),i=f.create(s.x);if(i===m)return;const a=f.create(n*f.create(w+i*l));if(a===m)return;let c=(s.x===i?0:2)|Number(s.y&y),u=a;return o&&U(a)&&(u=f.neg(a),c^=1),new T(i,u,c)}}}(t,n,o);return(0,s.createHmacDrbg)(r.outputLen,f.BYTES,c)(i,u)},verify:function(r,n,o,i={}){const{lowS:a,prehash:c,format:u}=d(i,x);if(o=(0,s.ensureBytes)("publicKey",o),n=C((0,s.ensureBytes)("message",n),c),"strict"in i)throw new Error("options.strict was renamed to lowS");const l=void 0===u?function(e){let r;const n="string"==typeof e||(0,s.isBytes)(e),o=!n&&null!==e&&"object"==typeof e&&"bigint"==typeof e.r&&"bigint"==typeof e.s;if(!n&&!o)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(o)r=new T(e.r,e.s);else if(n){try{r=T.fromBytes((0,s.ensureBytes)("sig",e),"der")}catch(e){if(!(e instanceof t.DER.Err))throw e}if(!r)try{r=T.fromBytes((0,s.ensureBytes)("sig",e),"compact")}catch(e){return!1}}return r||!1}(r):T.fromBytes((0,s.ensureBytes)("sig",r),u);if(!1===l)return!1;try{const t=e.fromBytes(o);if(a&&l.hasHighS())return!1;const{r,s}=l,i=K(n),c=f.inv(s),u=f.create(i*c),d=f.create(r*c),m=e.BASE.multiplyUnsafe(u).add(t.multiplyUnsafe(d));return!m.is0()&&f.create(m.x)===r}catch(e){return!1}},recoverPublicKey:function(e,t,r={}){const{prehash:n}=d(r,x);return t=C(t,n),T.fromBytes(e,"recovered").recoverPublicKey(t).toBytes()},Signature:T,hash:r})}function S(e){const t={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},r=e.Fp;let n=e.allowedPrivateKeyLengths?Array.from(new Set(e.allowedPrivateKeyLengths.map(e=>Math.ceil(e/2)))):void 0;return{CURVE:t,curveOpts:{Fp:r,Fn:(0,a.Field)(t.n,{BITS:e.nBitLength,allowedLengths:n,modFromBytes:e.wrapPrivateKey}),allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes}}}function x(e,t,r){return function(n){const o=e.sqr(n),s=e.mul(o,n);return e.add(e.add(s,e.mul(n,t)),r)}}}}]);