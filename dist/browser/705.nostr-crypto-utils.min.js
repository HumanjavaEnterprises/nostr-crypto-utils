/*! For license information please see 705.nostr-crypto-utils.min.js.LICENSE.txt */
"use strict";(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[705],{1705:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.DER=e.DERErr=void 0,e.weierstrassPoints=p,e.weierstrass=function(t){const r=function(t){const e=(0,n.validateBasic)(t);return i.validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:l,n:u}=r,d=l.BYTES+1,f=2*l.BYTES+1;function m(t){return(0,o.mod)(t,u)}function y(t){return(0,o.invert)(t,u)}const{ProjectivePoint:w,normPrivateKeyToScalar:g,weierstrassEquation:E,isWithinCurveOrder:v}=p({...r,toBytes(t,e,r){const n=e.toAffine(),o=l.toBytes(n.x),a=i.concatBytes;return(0,s.abool)("isCompressed",r),r?a(Uint8Array.from([e.hasEvenY()?2:3]),o):a(Uint8Array.from([4]),o,l.toBytes(n.y))},fromBytes(t){const e=t.length,r=t[0],n=t.subarray(1);if(e!==d||2!==r&&3!==r){if(e===f&&4===r)return{x:l.fromBytes(n.subarray(0,l.BYTES)),y:l.fromBytes(n.subarray(l.BYTES,2*l.BYTES))};throw new Error("invalid Point, expected length of "+d+", or uncompressed "+f+", got "+e)}{const t=i.bytesToNumberBE(n);if(!i.inRange(t,h,l.ORDER))throw new Error("Point is not on curve");const e=E(t);let o;try{o=l.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~r)!=((o&h)===h)&&(o=l.neg(o)),{x:t,y:o}}}}),b=t=>i.bytesToHex(i.numberToBytesBE(t,r.nByteLength));function B(t){return t>u>>h}const R=(t,e,r)=>i.bytesToNumberBE(t.slice(e,r));class x{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const e=r.nByteLength;return t=(0,s.ensureBytes)("compactSignature",t,2*e),new x(R(t,0,e),R(t,e,2*e))}static fromDER(t){const{r,s:n}=e.DER.toSig((0,s.ensureBytes)("DER",t));return new x(r,n)}assertValidity(){i.aInRange("r",this.r,h,u),i.aInRange("s",this.s,h,u)}addRecoveryBit(t){return new x(this.r,this.s,t)}recoverPublicKey(t){const{r:e,s:n,recovery:o}=this,i=T((0,s.ensureBytes)("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const a=2===o||3===o?e+r.n:e;if(a>=l.ORDER)throw new Error("recovery id 2 or 3 invalid");const u=1&o?"03":"02",d=w.fromHex(u+b(a)),c=y(a),h=m(-i*c),f=m(n*c),p=w.BASE.multiplyAndAddUnsafe(d,h,f);if(!p)throw new Error("point at infinify");return p.assertValidity(),p}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,m(-this.s),this.recovery):this}toDERRawBytes(){return i.hexToBytes(this.toDERHex())}toDERHex(){return e.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return i.hexToBytes(this.toCompactHex())}toCompactHex(){return b(this.r)+b(this.s)}}const S={isValidPrivateKey(t){try{return g(t),!0}catch(t){return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const t=(0,o.getMinHashLength)(r.n);return(0,o.mapHashToField)(r.randomBytes(t),r.n)},precompute:(t=8,e=w.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function O(t){const e=i.isBytes(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===d||n===f:r?n===2*d||n===2*f:t instanceof w}const A=r.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=i.bytesToNumberBE(t),n=8*t.length-r.nBitLength;return n>0?e>>BigInt(n):e},T=r.bits2int_modN||function(t){return m(A(t))},q=i.bitMask(r.nBitLength);function z(t){return i.aInRange("num < 2^"+r.nBitLength,t,c,q),i.numberToBytesBE(t,r.nByteLength)}const N={lowS:r.lowS,prehash:!1},P={lowS:r.lowS,prehash:!1};return w.BASE._setWindowSize(8),{CURVE:r,getPublicKey:function(t,e=!0){return w.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(O(t))throw new Error("first arg must be private key");if(!O(e))throw new Error("second arg must be public key");return w.fromHex(e).multiply(g(t)).toRawBytes(r)},sign:function(t,e,n=N){const{seed:o,k2sig:u}=function(t,e,n=N){if(["recovered","canonical"].some((t=>t in n)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:u}=r;let{lowS:d,prehash:f,extraEntropy:p}=n;null==d&&(d=!0),t=(0,s.ensureBytes)("msgHash",t),a(n),f&&(t=(0,s.ensureBytes)("prehashed msgHash",o(t)));const E=T(t),b=g(e),R=[z(b),z(E)];if(null!=p&&!1!==p){const t=!0===p?u(l.BYTES):p;R.push((0,s.ensureBytes)("extraEntropy",t))}const S=i.concatBytes(...R),O=E;return{seed:S,k2sig:function(t){const e=A(t);if(!v(e))return;const r=y(e),n=w.BASE.multiply(e).toAffine(),o=m(n.x);if(o===c)return;const i=m(r*m(O+o*b));if(i===c)return;let s=(n.x===o?0:2)|Number(n.y&h),a=i;return d&&B(i)&&(a=function(t){return B(t)?m(-t):t}(i),s^=1),new x(o,a,s)}}}(t,e,n),d=r;return i.createHmacDrbg(d.hash.outputLen,d.nByteLength,d.hmac)(o,u)},verify:function(t,n,o,l=P){const u=t;n=(0,s.ensureBytes)("msgHash",n),o=(0,s.ensureBytes)("publicKey",o);const{lowS:d,prehash:c,format:h}=l;if(a(l),"strict"in l)throw new Error("options.strict was renamed to lowS");if(void 0!==h&&"compact"!==h&&"der"!==h)throw new Error("format must be compact or der");const f="string"==typeof u||i.isBytes(u),p=!f&&!h&&"object"==typeof u&&null!==u&&"bigint"==typeof u.r&&"bigint"==typeof u.s;if(!f&&!p)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let g,E;try{if(p&&(g=new x(u.r,u.s)),f){try{"compact"!==h&&(g=x.fromDER(u))}catch(t){if(!(t instanceof e.DER.Err))throw t}g||"der"===h||(g=x.fromCompact(u))}E=w.fromHex(o)}catch(t){return!1}if(!g)return!1;if(d&&g.hasHighS())return!1;c&&(n=r.hash(n));const{r:v,s:b}=g,B=T(n),R=y(b),S=m(B*R),O=m(v*R),A=w.BASE.multiplyAndAddUnsafe(E,S,O)?.toAffine();return!!A&&m(A.x)===v},ProjectivePoint:w,Signature:x,utils:S}},e.SWUFpSqrtRatio=w,e.mapToCurveSimpleSWU=function(t,e){if((0,o.validateField)(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=w(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return n=>{let o,i,s,a,l,u,d,c;o=t.sqr(n),o=t.mul(o,e.Z),i=t.sqr(o),i=t.add(i,o),s=t.add(i,t.ONE),s=t.mul(s,e.B),a=t.cmov(e.Z,t.neg(i),!t.eql(i,t.ZERO)),a=t.mul(a,e.A),i=t.sqr(s),u=t.sqr(a),l=t.mul(u,e.A),i=t.add(i,l),i=t.mul(i,s),u=t.mul(u,a),l=t.mul(u,e.B),i=t.add(i,l),d=t.mul(o,s);const{isValid:h,value:f}=r(i,u);c=t.mul(o,n),c=t.mul(c,f),d=t.cmov(d,s,h),c=t.cmov(c,f,h);const m=t.isOdd(n)===t.isOdd(c);return c=t.cmov(t.neg(c),c,m),d=t.div(d,a),{x:d,y:c}}};const n=r(2422),o=r(4967),i=r(1484),s=r(1484);function a(t){void 0!==t.lowS&&(0,s.abool)("lowS",t.lowS),void 0!==t.prehash&&(0,s.abool)("prehash",t.prehash)}const{bytesToNumberBE:l,hexToBytes:u}=i;class d extends Error{constructor(t=""){super(t)}}e.DERErr=d,e.DER={Err:d,_tlv:{encode:(t,r)=>{const{Err:n}=e.DER;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&r.length)throw new n("tlv.encode: unpadded data");const o=r.length/2,s=i.numberToHexUnpadded(o);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const a=o>127?i.numberToHexUnpadded(s.length/2|128):"";return i.numberToHexUnpadded(t)+a+s+r},decode(t,r){const{Err:n}=e.DER;let o=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(r.length<2||r[o++]!==t)throw new n("tlv.decode: wrong tlv");const i=r[o++];let s=0;if(128&i){const t=127&i;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const e=r.subarray(o,o+t);if(e.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===e[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of e)s=s<<8|t;if(o+=t,s<128)throw new n("tlv.decode(long): not minimal encoding")}else s=i;const a=r.subarray(o,o+s);if(a.length!==s)throw new n("tlv.decode: wrong value length");return{v:a,l:r.subarray(o+s)}}},_int:{encode(t){const{Err:r}=e.DER;if(t<c)throw new r("integer: negative integers are not allowed");let n=i.numberToHexUnpadded(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new r("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:r}=e.DER;if(128&t[0])throw new r("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new r("invalid signature integer: unnecessary leading zero");return l(t)}},toSig(t){const{Err:r,_int:n,_tlv:o}=e.DER,s="string"==typeof t?u(t):t;i.abytes(s);const{v:a,l}=o.decode(48,s);if(l.length)throw new r("invalid signature: left bytes after parsing");const{v:d,l:c}=o.decode(2,a),{v:h,l:f}=o.decode(2,c);if(f.length)throw new r("invalid signature: left bytes after parsing");return{r:n.decode(d),s:n.decode(h)}},hexFromSig(t){const{_tlv:r,_int:n}=e.DER,o=r.encode(2,n.encode(t.r))+r.encode(2,n.encode(t.s));return r.encode(48,o)}};const c=BigInt(0),h=BigInt(1),f=BigInt(2),m=BigInt(3),y=BigInt(4);function p(t){const e=function(t){const e=(0,n.validateBasic)(t);i.validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:o,a:s}=e;if(r){if(!o.eql(s,o.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,a=(0,o.Field)(e.n,e.nBitLength),l=e.toBytes||((t,e,n)=>{const o=e.toAffine();return i.concatBytes(Uint8Array.from([4]),r.toBytes(o.x),r.toBytes(o.y))}),u=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function d(t){const{a:n,b:o}=e,i=r.sqr(t),s=r.mul(i,t);return r.add(r.add(s,r.mul(t,n)),o)}if(!r.eql(r.sqr(e.Gy),d(e.Gx)))throw new Error("bad generator point: equation left != right");function f(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:a,n:l}=e;if(r&&"bigint"!=typeof t){if(i.isBytes(t)&&(t=i.bytesToHex(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("invalid private key");t=t.padStart(2*n,"0")}let u;try{u="bigint"==typeof t?t:i.bytesToNumberBE((0,s.ensureBytes)("private key",t,n))}catch(e){throw new Error("invalid private key, expected hex or "+n+" bytes, got "+typeof t)}return a&&(u=(0,o.mod)(u,l)),i.aInRange("private key",u,h,l),u}function y(t){if(!(t instanceof g))throw new Error("ProjectivePoint expected")}const p=(0,s.memoized)(((t,e)=>{const{px:n,py:o,pz:i}=t;if(r.eql(i,r.ONE))return{x:n,y:o};const s=t.is0();null==e&&(e=s?r.ONE:r.inv(i));const a=r.mul(n,e),l=r.mul(o,e),u=r.mul(i,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:a,y:l}})),w=(0,s.memoized)((t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:n,y:o}=t.toAffine();if(!r.isValid(n)||!r.isValid(o))throw new Error("bad point: x or y not FE");const i=r.sqr(o),s=d(n);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class g{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required");Object.freeze(this)}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof g)throw new Error("projective point not allowed");const o=t=>r.eql(t,r.ZERO);return o(e)&&o(n)?g.ZERO:new g(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(g.fromAffine)}static fromHex(t){const e=g.fromAffine(u((0,s.ensureBytes)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return g.BASE.multiply(f(t))}static msm(t,e){return(0,n.pippenger)(g,a,t,e)}_setWindowSize(t){v.setWindowSize(this,t)}assertValidity(){w(this)}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){y(t);const{px:e,py:n,pz:o}=this,{px:i,py:s,pz:a}=t,l=r.eql(r.mul(e,a),r.mul(i,o)),u=r.eql(r.mul(n,a),r.mul(s,o));return l&&u}negate(){return new g(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,o=r.mul(n,m),{px:i,py:s,pz:a}=this;let l=r.ZERO,u=r.ZERO,d=r.ZERO,c=r.mul(i,i),h=r.mul(s,s),f=r.mul(a,a),y=r.mul(i,s);return y=r.add(y,y),d=r.mul(i,a),d=r.add(d,d),l=r.mul(t,d),u=r.mul(o,f),u=r.add(l,u),l=r.sub(h,u),u=r.add(h,u),u=r.mul(l,u),l=r.mul(y,l),d=r.mul(o,d),f=r.mul(t,f),y=r.sub(c,f),y=r.mul(t,y),y=r.add(y,d),d=r.add(c,c),c=r.add(d,c),c=r.add(c,f),c=r.mul(c,y),u=r.add(u,c),f=r.mul(s,a),f=r.add(f,f),c=r.mul(f,y),l=r.sub(l,c),d=r.mul(f,h),d=r.add(d,d),d=r.add(d,d),new g(l,u,d)}add(t){y(t);const{px:n,py:o,pz:i}=this,{px:s,py:a,pz:l}=t;let u=r.ZERO,d=r.ZERO,c=r.ZERO;const h=e.a,f=r.mul(e.b,m);let p=r.mul(n,s),w=r.mul(o,a),E=r.mul(i,l),v=r.add(n,o),b=r.add(s,a);v=r.mul(v,b),b=r.add(p,w),v=r.sub(v,b),b=r.add(n,i);let B=r.add(s,l);return b=r.mul(b,B),B=r.add(p,E),b=r.sub(b,B),B=r.add(o,i),u=r.add(a,l),B=r.mul(B,u),u=r.add(w,E),B=r.sub(B,u),c=r.mul(h,b),u=r.mul(f,E),c=r.add(u,c),u=r.sub(w,c),c=r.add(w,c),d=r.mul(u,c),w=r.add(p,p),w=r.add(w,p),E=r.mul(h,E),b=r.mul(f,b),w=r.add(w,E),E=r.sub(p,E),E=r.mul(h,E),b=r.add(b,E),p=r.mul(w,b),d=r.add(d,p),p=r.mul(B,b),u=r.mul(v,u),u=r.sub(u,p),p=r.mul(v,w),c=r.mul(B,c),c=r.add(c,p),new g(u,d,c)}subtract(t){return this.add(t.negate())}is0(){return this.equals(g.ZERO)}wNAF(t){return v.wNAFCached(this,t,g.normalizeZ)}multiplyUnsafe(t){const{endo:n,n:o}=e;i.aInRange("scalar",t,c,o);const s=g.ZERO;if(t===c)return s;if(this.is0()||t===h)return this;if(!n||v.hasPrecomputes(this))return v.wNAFCachedUnsafe(this,t,g.normalizeZ);let{k1neg:a,k1:l,k2neg:u,k2:d}=n.splitScalar(t),f=s,m=s,y=this;for(;l>c||d>c;)l&h&&(f=f.add(y)),d&h&&(m=m.add(y)),y=y.double(),l>>=h,d>>=h;return a&&(f=f.negate()),u&&(m=m.negate()),m=new g(r.mul(m.px,n.beta),m.py,m.pz),f.add(m)}multiply(t){const{endo:n,n:o}=e;let s,a;if(i.aInRange("scalar",t,h,o),n){const{k1neg:e,k1:o,k2neg:i,k2:l}=n.splitScalar(t);let{p:u,f:d}=this.wNAF(o),{p:c,f:h}=this.wNAF(l);u=v.constTimeNegate(e,u),c=v.constTimeNegate(i,c),c=new g(r.mul(c.px,n.beta),c.py,c.pz),s=u.add(c),a=d.add(h)}else{const{p:e,f:r}=this.wNAF(t);s=e,a=r}return g.normalizeZ([s,a])[0]}multiplyAndAddUnsafe(t,e,r){const n=g.BASE,o=(t,e)=>e!==c&&e!==h&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,r));return i.is0()?void 0:i}toAffine(t){return p(this,t)}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===h)return!0;if(r)return r(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===h?this:r?r(g,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return(0,s.abool)("isCompressed",t),this.assertValidity(),l(g,this,t)}toHex(t=!0){return(0,s.abool)("isCompressed",t),i.bytesToHex(this.toRawBytes(t))}}g.BASE=new g(e.Gx,e.Gy,r.ONE),g.ZERO=new g(r.ZERO,r.ONE,r.ZERO);const E=e.nBitLength,v=(0,n.wNAF)(g,e.endo?Math.ceil(E/2):E);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:f,weierstrassEquation:d,isWithinCurveOrder:function(t){return i.inRange(t,h,e.n)}}}function w(t,e){const r=t.ORDER;let n=c;for(let t=r-h;t%f===c;t/=f)n+=h;const o=n,i=f<<o-h-h,s=i*f,a=(r-h)/s,l=(a-h)/f,u=s-h,d=i,p=t.pow(e,a),w=t.pow(e,(a+h)/f);let g=(e,r)=>{let n=p,i=t.pow(r,u),s=t.sqr(i);s=t.mul(s,r);let a=t.mul(e,s);a=t.pow(a,l),a=t.mul(a,i),i=t.mul(a,r),s=t.mul(a,e);let c=t.mul(s,i);a=t.pow(c,d);let m=t.eql(a,t.ONE);i=t.mul(s,w),a=t.mul(c,n),s=t.cmov(i,s,m),c=t.cmov(a,c,m);for(let e=o;e>h;e--){let r=e-f;r=f<<r-h;let o=t.pow(c,r);const a=t.eql(o,t.ONE);i=t.mul(s,n),n=t.mul(n,n),o=t.mul(c,n),s=t.cmov(i,s,a),c=t.cmov(o,c,a)}return{isValid:m,value:s}};if(t.ORDER%y===m){const r=(t.ORDER-m)/y,n=t.sqrt(t.neg(e));g=(e,o)=>{let i=t.sqr(o);const s=t.mul(e,o);i=t.mul(i,s);let a=t.pow(i,r);a=t.mul(a,s);const l=t.mul(a,n),u=t.mul(t.sqr(a),o),d=t.eql(u,e);return{isValid:d,value:t.cmov(l,a,d)}}}return g}}}]);