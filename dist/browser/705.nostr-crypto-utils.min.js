/*! For license information please see 705.nostr-crypto-utils.min.js.LICENSE.txt */
"use strict";(this.webpackChunkNostrCryptoUtils=this.webpackChunkNostrCryptoUtils||[]).push([[705],{1705:(t,e,r)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.DER=void 0,e.weierstrassPoints=y,e.weierstrass=function(t){const r=function(t){const e=(0,n.validateBasic)(t);return i.validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:l,n:u}=r,h=l.BYTES+1,f=2*l.BYTES+1;function m(t){return o.mod(t,u)}function p(t){return o.invert(t,u)}const{ProjectivePoint:w,normPrivateKeyToScalar:g,weierstrassEquation:E,isWithinCurveOrder:v}=y({...r,toBytes(t,e,r){const n=e.toAffine(),o=l.toBytes(n.x),a=i.concatBytes;return(0,s.abool)("isCompressed",r),r?a(Uint8Array.from([e.hasEvenY()?2:3]),o):a(Uint8Array.from([4]),o,l.toBytes(n.y))},fromBytes(t){const e=t.length,r=t[0],n=t.subarray(1);if(e!==h||2!==r&&3!==r){if(e===f&&4===r)return{x:l.fromBytes(n.subarray(0,l.BYTES)),y:l.fromBytes(n.subarray(l.BYTES,2*l.BYTES))};throw new Error("invalid Point, expected length of "+h+", or uncompressed "+f+", got "+e)}{const t=i.bytesToNumberBE(n);if(!i.inRange(t,c,l.ORDER))throw new Error("Point is not on curve");const e=E(t);let o;try{o=l.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~r)!=((o&c)===c)&&(o=l.neg(o)),{x:t,y:o}}}}),b=t=>i.bytesToHex(i.numberToBytesBE(t,r.nByteLength));function B(t){return t>u>>c}const x=(t,e,r)=>i.bytesToNumberBE(t.slice(e,r));class R{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const e=r.nByteLength;return t=(0,s.ensureBytes)("compactSignature",t,2*e),new R(x(t,0,e),x(t,e,2*e))}static fromDER(t){const{r,s:n}=e.DER.toSig((0,s.ensureBytes)("DER",t));return new R(r,n)}assertValidity(){i.aInRange("r",this.r,c,u),i.aInRange("s",this.s,c,u)}addRecoveryBit(t){return new R(this.r,this.s,t)}recoverPublicKey(t){const{r:e,s:n,recovery:o}=this,i=T((0,s.ensureBytes)("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const a=2===o||3===o?e+r.n:e;if(a>=l.ORDER)throw new Error("recovery id 2 or 3 invalid");const u=1&o?"03":"02",d=w.fromHex(u+b(a)),c=p(a),h=m(-i*c),f=m(n*c),y=w.BASE.multiplyAndAddUnsafe(d,h,f);if(!y)throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new R(this.r,m(-this.s),this.recovery):this}toDERRawBytes(){return i.hexToBytes(this.toDERHex())}toDERHex(){return e.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return i.hexToBytes(this.toCompactHex())}toCompactHex(){return b(this.r)+b(this.s)}}const S={isValidPrivateKey(t){try{return g(t),!0}catch(t){return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const t=o.getMinHashLength(r.n);return o.mapHashToField(r.randomBytes(t),r.n)},precompute:(t=8,e=w.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function O(t){const e=i.isBytes(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===h||n===f:r?n===2*h||n===2*f:t instanceof w}const A=r.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=i.bytesToNumberBE(t),n=8*t.length-r.nBitLength;return n>0?e>>BigInt(n):e},T=r.bits2int_modN||function(t){return m(A(t))},q=i.bitMask(r.nBitLength);function z(t){return i.aInRange("num < 2^"+r.nBitLength,t,d,q),i.numberToBytesBE(t,r.nByteLength)}const N={lowS:r.lowS,prehash:!1},P={lowS:r.lowS,prehash:!1};return w.BASE._setWindowSize(8),{CURVE:r,getPublicKey:function(t,e=!0){return w.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(O(t))throw new Error("first arg must be private key");if(!O(e))throw new Error("second arg must be public key");return w.fromHex(e).multiply(g(t)).toRawBytes(r)},sign:function(t,e,n=N){const{seed:o,k2sig:u}=function(t,e,n=N){if(["recovered","canonical"].some((t=>t in n)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:u}=r;let{lowS:h,prehash:f,extraEntropy:y}=n;null==h&&(h=!0),t=(0,s.ensureBytes)("msgHash",t),a(n),f&&(t=(0,s.ensureBytes)("prehashed msgHash",o(t)));const E=T(t),b=g(e),x=[z(b),z(E)];if(null!=y&&!1!==y){const t=!0===y?u(l.BYTES):y;x.push((0,s.ensureBytes)("extraEntropy",t))}const S=i.concatBytes(...x),O=E;return{seed:S,k2sig:function(t){const e=A(t);if(!v(e))return;const r=p(e),n=w.BASE.multiply(e).toAffine(),o=m(n.x);if(o===d)return;const i=m(r*m(O+o*b));if(i===d)return;let s=(n.x===o?0:2)|Number(n.y&c),a=i;return h&&B(i)&&(a=function(t){return B(t)?m(-t):t}(i),s^=1),new R(o,a,s)}}}(t,e,n),h=r;return i.createHmacDrbg(h.hash.outputLen,h.nByteLength,h.hmac)(o,u)},verify:function(t,n,o,l=P){const u=t;n=(0,s.ensureBytes)("msgHash",n),o=(0,s.ensureBytes)("publicKey",o);const{lowS:d,prehash:c,format:h}=l;if(a(l),"strict"in l)throw new Error("options.strict was renamed to lowS");if(void 0!==h&&"compact"!==h&&"der"!==h)throw new Error("format must be compact or der");const f="string"==typeof u||i.isBytes(u),y=!f&&!h&&"object"==typeof u&&null!==u&&"bigint"==typeof u.r&&"bigint"==typeof u.s;if(!f&&!y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let g,E;try{if(y&&(g=new R(u.r,u.s)),f){try{"compact"!==h&&(g=R.fromDER(u))}catch(t){if(!(t instanceof e.DER.Err))throw t}g||"der"===h||(g=R.fromCompact(u))}E=w.fromHex(o)}catch(t){return!1}if(!g)return!1;if(d&&g.hasHighS())return!1;c&&(n=r.hash(n));const{r:v,s:b}=g,B=T(n),x=p(b),S=m(B*x),O=m(v*x),A=w.BASE.multiplyAndAddUnsafe(E,S,O)?.toAffine();return!!A&&m(A.x)===v},ProjectivePoint:w,Signature:R,utils:S}},e.SWUFpSqrtRatio=p,e.mapToCurveSimpleSWU=function(t,e){if(o.validateField(t),!t.isValid(e.A)||!t.isValid(e.B)||!t.isValid(e.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=p(t,e.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return n=>{let o,i,s,a,l,u,d,c;o=t.sqr(n),o=t.mul(o,e.Z),i=t.sqr(o),i=t.add(i,o),s=t.add(i,t.ONE),s=t.mul(s,e.B),a=t.cmov(e.Z,t.neg(i),!t.eql(i,t.ZERO)),a=t.mul(a,e.A),i=t.sqr(s),u=t.sqr(a),l=t.mul(u,e.A),i=t.add(i,l),i=t.mul(i,s),u=t.mul(u,a),l=t.mul(u,e.B),i=t.add(i,l),d=t.mul(o,s);const{isValid:h,value:f}=r(i,u);c=t.mul(o,n),c=t.mul(c,f),d=t.cmov(d,s,h),c=t.cmov(c,f,h);const m=t.isOdd(n)===t.isOdd(c);return c=t.cmov(t.neg(c),c,m),d=t.div(d,a),{x:d,y:c}}};const n=r(2422),o=r(4967),i=r(1484),s=r(1484);function a(t){void 0!==t.lowS&&(0,s.abool)("lowS",t.lowS),void 0!==t.prehash&&(0,s.abool)("prehash",t.prehash)}const{bytesToNumberBE:l,hexToBytes:u}=i;e.DER={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode:(t,r)=>{const{Err:n}=e.DER;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&r.length)throw new n("tlv.encode: unpadded data");const o=r.length/2,s=i.numberToHexUnpadded(o);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const a=o>127?i.numberToHexUnpadded(s.length/2|128):"";return i.numberToHexUnpadded(t)+a+s+r},decode(t,r){const{Err:n}=e.DER;let o=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(r.length<2||r[o++]!==t)throw new n("tlv.decode: wrong tlv");const i=r[o++];let s=0;if(128&i){const t=127&i;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const e=r.subarray(o,o+t);if(e.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===e[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of e)s=s<<8|t;if(o+=t,s<128)throw new n("tlv.decode(long): not minimal encoding")}else s=i;const a=r.subarray(o,o+s);if(a.length!==s)throw new n("tlv.decode: wrong value length");return{v:a,l:r.subarray(o+s)}}},_int:{encode(t){const{Err:r}=e.DER;if(t<d)throw new r("integer: negative integers are not allowed");let n=i.numberToHexUnpadded(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new r("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:r}=e.DER;if(128&t[0])throw new r("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new r("invalid signature integer: unnecessary leading zero");return l(t)}},toSig(t){const{Err:r,_int:n,_tlv:o}=e.DER,s="string"==typeof t?u(t):t;i.abytes(s);const{v:a,l}=o.decode(48,s);if(l.length)throw new r("invalid signature: left bytes after parsing");const{v:d,l:c}=o.decode(2,a),{v:h,l:f}=o.decode(2,c);if(f.length)throw new r("invalid signature: left bytes after parsing");return{r:n.decode(d),s:n.decode(h)}},hexFromSig(t){const{_tlv:r,_int:n}=e.DER,o=r.encode(2,n.encode(t.r))+r.encode(2,n.encode(t.s));return r.encode(48,o)}};const d=BigInt(0),c=BigInt(1),h=BigInt(2),f=BigInt(3),m=BigInt(4);function y(t){const e=function(t){const e=(0,n.validateBasic)(t);i.validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:o,a:s}=e;if(r){if(!o.eql(s,o.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,a=o.Field(e.n,e.nBitLength),l=e.toBytes||((t,e,n)=>{const o=e.toAffine();return i.concatBytes(Uint8Array.from([4]),r.toBytes(o.x),r.toBytes(o.y))}),u=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function h(t){const{a:n,b:o}=e,i=r.sqr(t),s=r.mul(i,t);return r.add(r.add(s,r.mul(t,n)),o)}if(!r.eql(r.sqr(e.Gy),h(e.Gx)))throw new Error("bad generator point: equation left != right");function m(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:a,n:l}=e;if(r&&"bigint"!=typeof t){if(i.isBytes(t)&&(t=i.bytesToHex(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("invalid private key");t=t.padStart(2*n,"0")}let u;try{u="bigint"==typeof t?t:i.bytesToNumberBE((0,s.ensureBytes)("private key",t,n))}catch(e){throw new Error("invalid private key, expected hex or "+n+" bytes, got "+typeof t)}return a&&(u=o.mod(u,l)),i.aInRange("private key",u,c,l),u}function y(t){if(!(t instanceof g))throw new Error("ProjectivePoint expected")}const p=(0,s.memoized)(((t,e)=>{const{px:n,py:o,pz:i}=t;if(r.eql(i,r.ONE))return{x:n,y:o};const s=t.is0();null==e&&(e=s?r.ONE:r.inv(i));const a=r.mul(n,e),l=r.mul(o,e),u=r.mul(i,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw new Error("invZ was invalid");return{x:a,y:l}})),w=(0,s.memoized)((t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:n,y:o}=t.toAffine();if(!r.isValid(n)||!r.isValid(o))throw new Error("bad point: x or y not FE");const i=r.sqr(o),s=h(n);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class g{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required");Object.freeze(this)}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof g)throw new Error("projective point not allowed");const o=t=>r.eql(t,r.ZERO);return o(e)&&o(n)?g.ZERO:new g(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(g.fromAffine)}static fromHex(t){const e=g.fromAffine(u((0,s.ensureBytes)("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return g.BASE.multiply(m(t))}static msm(t,e){return(0,n.pippenger)(g,a,t,e)}_setWindowSize(t){v.setWindowSize(this,t)}assertValidity(){w(this)}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){y(t);const{px:e,py:n,pz:o}=this,{px:i,py:s,pz:a}=t,l=r.eql(r.mul(e,a),r.mul(i,o)),u=r.eql(r.mul(n,a),r.mul(s,o));return l&&u}negate(){return new g(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,o=r.mul(n,f),{px:i,py:s,pz:a}=this;let l=r.ZERO,u=r.ZERO,d=r.ZERO,c=r.mul(i,i),h=r.mul(s,s),m=r.mul(a,a),y=r.mul(i,s);return y=r.add(y,y),d=r.mul(i,a),d=r.add(d,d),l=r.mul(t,d),u=r.mul(o,m),u=r.add(l,u),l=r.sub(h,u),u=r.add(h,u),u=r.mul(l,u),l=r.mul(y,l),d=r.mul(o,d),m=r.mul(t,m),y=r.sub(c,m),y=r.mul(t,y),y=r.add(y,d),d=r.add(c,c),c=r.add(d,c),c=r.add(c,m),c=r.mul(c,y),u=r.add(u,c),m=r.mul(s,a),m=r.add(m,m),c=r.mul(m,y),l=r.sub(l,c),d=r.mul(m,h),d=r.add(d,d),d=r.add(d,d),new g(l,u,d)}add(t){y(t);const{px:n,py:o,pz:i}=this,{px:s,py:a,pz:l}=t;let u=r.ZERO,d=r.ZERO,c=r.ZERO;const h=e.a,m=r.mul(e.b,f);let p=r.mul(n,s),w=r.mul(o,a),E=r.mul(i,l),v=r.add(n,o),b=r.add(s,a);v=r.mul(v,b),b=r.add(p,w),v=r.sub(v,b),b=r.add(n,i);let B=r.add(s,l);return b=r.mul(b,B),B=r.add(p,E),b=r.sub(b,B),B=r.add(o,i),u=r.add(a,l),B=r.mul(B,u),u=r.add(w,E),B=r.sub(B,u),c=r.mul(h,b),u=r.mul(m,E),c=r.add(u,c),u=r.sub(w,c),c=r.add(w,c),d=r.mul(u,c),w=r.add(p,p),w=r.add(w,p),E=r.mul(h,E),b=r.mul(m,b),w=r.add(w,E),E=r.sub(p,E),E=r.mul(h,E),b=r.add(b,E),p=r.mul(w,b),d=r.add(d,p),p=r.mul(B,b),u=r.mul(v,u),u=r.sub(u,p),p=r.mul(v,w),c=r.mul(B,c),c=r.add(c,p),new g(u,d,c)}subtract(t){return this.add(t.negate())}is0(){return this.equals(g.ZERO)}wNAF(t){return v.wNAFCached(this,t,g.normalizeZ)}multiplyUnsafe(t){const{endo:n,n:o}=e;i.aInRange("scalar",t,d,o);const s=g.ZERO;if(t===d)return s;if(this.is0()||t===c)return this;if(!n||v.hasPrecomputes(this))return v.wNAFCachedUnsafe(this,t,g.normalizeZ);let{k1neg:a,k1:l,k2neg:u,k2:h}=n.splitScalar(t),f=s,m=s,y=this;for(;l>d||h>d;)l&c&&(f=f.add(y)),h&c&&(m=m.add(y)),y=y.double(),l>>=c,h>>=c;return a&&(f=f.negate()),u&&(m=m.negate()),m=new g(r.mul(m.px,n.beta),m.py,m.pz),f.add(m)}multiply(t){const{endo:n,n:o}=e;let s,a;if(i.aInRange("scalar",t,c,o),n){const{k1neg:e,k1:o,k2neg:i,k2:l}=n.splitScalar(t);let{p:u,f:d}=this.wNAF(o),{p:c,f:h}=this.wNAF(l);u=v.constTimeNegate(e,u),c=v.constTimeNegate(i,c),c=new g(r.mul(c.px,n.beta),c.py,c.pz),s=u.add(c),a=d.add(h)}else{const{p:e,f:r}=this.wNAF(t);s=e,a=r}return g.normalizeZ([s,a])[0]}multiplyAndAddUnsafe(t,e,r){const n=g.BASE,o=(t,e)=>e!==d&&e!==c&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,r));return i.is0()?void 0:i}toAffine(t){return p(this,t)}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===c)return!0;if(r)return r(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===c?this:r?r(g,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return(0,s.abool)("isCompressed",t),this.assertValidity(),l(g,this,t)}toHex(t=!0){return(0,s.abool)("isCompressed",t),i.bytesToHex(this.toRawBytes(t))}}g.BASE=new g(e.Gx,e.Gy,r.ONE),g.ZERO=new g(r.ZERO,r.ONE,r.ZERO);const E=e.nBitLength,v=(0,n.wNAF)(g,e.endo?Math.ceil(E/2):E);return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:m,weierstrassEquation:h,isWithinCurveOrder:function(t){return i.inRange(t,c,e.n)}}}function p(t,e){const r=t.ORDER;let n=d;for(let t=r-c;t%h===d;t/=h)n+=c;const o=n,i=h<<o-c-c,s=i*h,a=(r-c)/s,l=(a-c)/h,u=s-c,y=i,p=t.pow(e,a),w=t.pow(e,(a+c)/h);let g=(e,r)=>{let n=p,i=t.pow(r,u),s=t.sqr(i);s=t.mul(s,r);let a=t.mul(e,s);a=t.pow(a,l),a=t.mul(a,i),i=t.mul(a,r),s=t.mul(a,e);let d=t.mul(s,i);a=t.pow(d,y);let f=t.eql(a,t.ONE);i=t.mul(s,w),a=t.mul(d,n),s=t.cmov(i,s,f),d=t.cmov(a,d,f);for(let e=o;e>c;e--){let r=e-h;r=h<<r-c;let o=t.pow(d,r);const a=t.eql(o,t.ONE);i=t.mul(s,n),n=t.mul(n,n),o=t.mul(d,n),s=t.cmov(i,s,a),d=t.cmov(o,d,a)}return{isValid:f,value:s}};if(t.ORDER%m===f){const r=(t.ORDER-f)/m,n=t.sqrt(t.neg(e));g=(e,o)=>{let i=t.sqr(o);const s=t.mul(e,o);i=t.mul(i,s);let a=t.pow(i,r);a=t.mul(a,s);const l=t.mul(a,n),u=t.mul(t.sqr(a),o),d=t.eql(u,e);return{isValid:d,value:t.cmov(l,a,d)}}}return g}}}]);